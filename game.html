<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç’°ä¿ç‰¹æ”»éšŠï¼šæ·¨åŒ–å…ˆé‹’</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            overflow: hidden;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            color: white;
            -webkit-tap-highlight-color: transparent;
        }
        #game-container {
            width: 100%;
            max-width: 450px;
            height: 100%;
            max-height: 850px;
            background: linear-gradient(180deg, #56ab2f 0%, #a8e063 100%);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            border-radius: 25px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 3px solid rgba(255,255,255,0.2);
            transition: background 0.5s ease, filter 0.5s ease;
        }
        .screen-shake { animation: shake-horizontal 0.1s linear infinite; }
        @keyframes shake-horizontal {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(3px); }
            75% { transform: translateX(-3px); }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            background-color: transparent;
            position: absolute;
            top: 0;
            left: 0;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
            z-index: 10;
        }
        .top-ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }
        .status-icons {
            display: flex;
            gap: 8px;
            user-select: none;
        }
        .status-icon {
            min-width: 30px;
            height: 30px;
            padding: 0 8px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 1px 1px 2px black;
        }
        .bottom-ui {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            pointer-events: auto;
            flex-direction: column;
        }
        .score-display, .lives-display {
            font-size: clamp(1rem, 3.5vw, 1.4rem); 
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 10px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.3);
            user-select: none;
        }
        #energy-bar-container {
            width: 100%;
            height: 28px; 
            background-color: rgba(0,0,0,0.4);
            border-radius: 14px;
            margin-top: 8px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.6);
            position: relative;
        }
        #energy-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #66BB6A, #AED581, #81C784, #AED581, #66BB6A);
            background-size: 300% 100%;
            animation: animated-gradient-subtle 4s ease infinite;
            border-radius: 11px 0 0 11px;
            transition: width 0.3s ease-in-out, background 0.3s ease-in-out, border-radius 0.1s linear;
        }
        .bar-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #energy-text {
            font-size: 0.9rem;
        }
        #energy-bar.full {
            background: linear-gradient(90deg, #FFD700, #FFB300, #FF8F00, #FFB300, #FFD700);
            background-size: 300% 100%;
            animation: animated-gradient-active 3s ease infinite, pulse-gold-shadow 1.5s infinite;
            border-radius: 11px;
        }
        
        @keyframes animated-gradient-subtle { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes animated-gradient-active { 0% { background-position: 200% 50%; } 50% { background-position: -100% 50%; } 100% { background-position: 200% 50%; } }
        @keyframes pulse-gold-shadow { 0% { box-shadow: 0 0 3px #FFD700, 0 0 5px #FFB300; } 50% { box-shadow: 0 0 10px 3px #FFD700, 0 0 15px 5px #FFB300; } 100% { box-shadow: 0 0 3px #FFD700, 0 0 5px #FFB300; } }

        #start-screen, #game-over-screen, #pause-screen, #how-to-play-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; z-index: 100; padding: 20px;
            backdrop-filter: blur(10px); 
            opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #start-screen.active, #game-over-screen.active, #pause-screen.active, #how-to-play-screen.active {
            opacity: 1; visibility: visible;
        }
        .screen-title {
            font-size: clamp(2rem, 8vw, 2.8rem); 
            font-weight: bold; margin-bottom: 20px;
            color: #A7F3D0; 
            text-shadow: 0 0 8px #A7F3D0, 0 0 15px #A7F3D0, 2px 2px 4px rgba(0,0,0,0.7);
        }
        .screen-text, .how-to-play-content p, .how-to-play-content li { font-size: clamp(0.9rem, 3vw, 1.1rem); margin-bottom: 12px; line-height: 1.5; }
        .how-to-play-content { max-height: 65vh; overflow-y: auto; padding-right: 10px; text-align: left; }
        .how-to-play-content h3 { font-size: clamp(1.1rem, 3.5vw, 1.4rem); color: #FFEB3B; margin-top: 18px; margin-bottom: 8px; }

        .action-button {
            padding: 10px 22px; font-size: clamp(1rem, 3.8vw, 1.2rem); font-weight: bold; color: #1A202C;
            background: linear-gradient(135deg, #81C784 0%, #A5D6A7 100%);
            border: none; border-radius: 10px; cursor: pointer; transition: all 0.2s ease-in-out;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2), inset 0 -2px 2px rgba(0,0,0,0.1);
            margin-top: 8px;
        }
        .action-button:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 12px rgba(0,0,0,0.3), inset 0 -2px 2px rgba(0,0,0,0.1); filter: brightness(1.1); }
        .action-button:active { transform: translateY(0px) scale(0.98); box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 -1px 1px rgba(0,0,0,0.1); }
        .button-secondary { background: linear-gradient(135deg, #FFB74D 0%, #FF9800 100%); }
        .button-danger { background: linear-gradient(135deg, #E57373 0%, #F44336 100%); }
        
        #pause-button {
            font-size: clamp(1.2rem, 4.5vw, 1.6rem); background-color: rgba(0,0,0,0.5);
            padding: 7px 12px; border-radius: 8px; cursor: pointer; user-select: none;
            border: 1px solid rgba(255,255,255,0.3); transition: background-color 0.2s;
        }
        #pause-button:hover { background-color: rgba(0,0,0,0.7); }
        .item-icon-canvas { display: inline-block; width: 22px; height: 22px; margin-right: 6px; vertical-align: middle; border: 1px solid #ccc; border-radius: 4px; background: #334; }
        
        #bonus-timer {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(4rem, 15vw, 6rem);
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 10px #FFB300, 3px 3px 5px rgba(0,0,0,0.7);
            z-index: 150;
            display: none; /* JS will manage visibility */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="bonus-timer"></div>
        
        <div class="ui-overlay">
            <div class="top-ui">
                <div id="score" class="score-display">åˆ†æ•¸: 0</div>
                <div class="status-icons">
                    <div id="slowmo-status" class="status-icon" style="display: none;"></div>
                    <div id="shield-status" class="status-icon" style="display: none;">ğŸ›¡ï¸</div>
                    <div id="multiplier-status" class="status-icon" style="display: none;"></div>
                </div>
                <div id="pause-button">II</div>
                <div id="lives" class="lives-display">ç”Ÿå‘½: 3</div>
            </div>

            <div class="bottom-ui">
                 <div id="energy-bar-container">
                    <div id="energy-bar"></div>
                    <div id="energy-text" class="bar-text">èƒ½é‡</div>
                </div>
            </div>
        </div>

        <div id="start-screen" class="active">
            <h1 class="screen-title">ç’°ä¿ç‰¹æ”»éšŠ</h1>
            <p class="screen-text">æ»‘å‹•æ‰‹æŒ‡ï¼Œæ·¨åŒ–æ±¡æŸ“ç‰©ï¼Œåœ¨çå‹µæ™‚é–“ä¸­å¥ªå–é«˜åˆ†ï¼</p>
            <button id="start-button" class="action-button">ğŸš€ é–‹å§‹éŠæˆ²</button>
            <button id="how-to-play-button" class="action-button button-secondary mt-4">ğŸ“– éŠæˆ²ç©æ³•</button>
        </div>

        <div id="game-over-screen">
            <h1 class="screen-title">éŠæˆ²çµæŸ</h1>
            <p id="final-score" class="screen-text">ä½ çš„æœ€çµ‚åˆ†æ•¸: 0</p>
            <button id="restart-button" class="action-button">ğŸ”„ é‡æ–°é–‹å§‹</button>
        </div>
        
        <div id="pause-screen">
            <h1 class="screen-title">éŠæˆ²æš«åœ</h1>
            <button id="resume-button" class="action-button">â–¶ï¸ ç¹¼çºŒéŠæˆ²</button>
            <button id="quit-button" class="action-button button-danger mt-4">ğŸšª çµæŸéŠæˆ²</button>
        </div>

        <div id="how-to-play-screen">
            <h1 class="screen-title">éŠæˆ²ç©æ³•èªªæ˜</h1>
            <div class="how-to-play-content">
                <p>ä½ çš„ä»»å‹™æ˜¯æ¸…é™¤å¾å¤©è€Œé™çš„æ±¡æŸ“ç‰©ï¼ŒåŒæ™‚é¿é–‹éœ€è¦ä¿è­·çš„è‡ªç„¶ä¹‹ç‰©ï¼Œç›¡å¯èƒ½åœ°ç²å¾—é«˜åˆ†ï¼</p>
                
                <h3 style="color: #FFCC80;">ğŸŒŸ çå‹µæ™‚é–“ (Bonus Time) ğŸŒŸ</h3>
                <ul>
                    <li>æ·¨åŒ–æ±¡æŸ“ç‰©å¯ç´¯ç©åº•éƒ¨ã€Œèƒ½é‡æ¢ã€ã€‚</li>
                    <li>èƒ½é‡æ¢é›†æ»¿æ™‚ï¼Œæœƒ**è‡ªå‹•è§¸ç™¼** 5 ç§’çš„ã€Œçå‹µæ™‚é–“ã€ï¼</li>
                    <li>åœ¨çå‹µæ™‚é–“å…§ï¼Œç•«é¢ä¸Šæœƒé™ä¸‹å¤§é‡å¯æ”¶é›†çš„**æ˜Ÿæ˜Ÿ**ï¼Œç›¡æƒ…æ»‘å‹•å¥ªå–é«˜åˆ†å§ï¼</li>
                     <li>æ¯æ¬¡é€²å…¥çå‹µæ™‚é–“ï¼Œæ˜Ÿæ˜Ÿçš„æ•¸é‡éƒ½æœƒå¢åŠ ï¼</li>
                </ul>

                <h3>â˜ ï¸ æ±¡æŸ“ç‰© (éœ€è¦æ·¨åŒ–)ï¼š</h3>
                <ul>
                    <li><canvas class="item-icon-canvas" data-type="plastic_icon"></canvas>å¡‘è† ç“¶æ€ªã€<canvas class="item-icon-canvas" data-type="fume_icon"></canvas>å»¢æ°£æ³¡æ³¡ã€<canvas class="item-icon-canvas" data-type="oil_icon"></canvas>æ²¹æ±¡åœ˜å¡Šã€‚</li>
                </ul>
                <h3>ğŸŒ³ ä¿è­·ç‰© (éœ€è¦é¿é–‹)ï¼š</h3>
                <ul>
                    <li><canvas class="item-icon-canvas" data-type="sapling_icon"></canvas>å°æ¨¹è‹—ã€<canvas class="item-icon-canvas" data-type="water_icon"></canvas>ç´”æ·¨æ°´æ»´ã€‚</li>
                </ul>
                <h3>ğŸ é“å…· (æ»‘å‹•ç²å–)ï¼š</h3>
                 <ul>
                    <li><canvas class="item-icon-canvas" data-type="slowmo_icon"></canvas>æ™‚é–“ç·©ç·©ã€<canvas class="item-icon-canvas" data-type="shield_icon"></canvas>å®ˆè­·å…‰ç›¾ã€<canvas class="item-icon-canvas" data-type="multi_icon"></canvas>é›™å€ç©åˆ†ã€<canvas class="item-icon-canvas" data-type="energy_icon"></canvas>èƒ½é‡è£œå……ã€‚</li>
                </ul>
                <p>ç¥ä½ å¥½é‹ï¼Œç’°ä¿ç‰¹æ”»éšŠå“¡ï¼</p>
            </div>
            <button id="close-how-to-play-button" class="action-button mt-6">ğŸ‘Œ æˆ‘æ˜ç™½äº†</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const energyBar = document.getElementById('energy-bar');
        const energyText = document.getElementById('energy-text');
        const shieldStatus = document.getElementById('shield-status');
        const multiplierStatus = document.getElementById('multiplier-status');
        const slowmoStatus = document.getElementById('slowmo-status');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const howToPlayScreen = document.getElementById('how-to-play-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const pauseButton = document.getElementById('pause-button');
        const resumeButton = document.getElementById('resume-button');
        const quitButton = document.getElementById('quit-button');
        const howToPlayButton = document.getElementById('how-to-play-button');
        const closeHowToPlayButton = document.getElementById('close-how-to-play-button');
        const bonusTimerDisplay = document.getElementById('bonus-timer');
        
        // --- Game State Variables ---
        let score = 0, lives = 3, energy = 0;
        const maxEnergy = 100;
        let gameObjects = [], particles = [], swipePath = [];
        let isSwiping = false, animationFrameId, gameState = 'start';
        let gameSpeedMultiplier = 1, baseSpawnInterval = 1200, currentSpawnInterval = 1200, lastSpawnTime = 0;
        let bonusLevel = 1, bonusTimeEndTime = 0;
        let prePauseGameState = '', pausedTime = 0; // For robust pause/resume
        
        // --- Item Effect Timers & Flags ---
        let isSlowMotionActive = false, slowMotionEndTime = 0;
        const SLOW_MOTION_DURATION = 15000;
        let isShieldActive = false;
        let isScoreMultiplierActive = false, scoreMultiplierEndTime = 0;
        const SCORE_MULTIPLIER_DURATION = 30000;
        const ITEM_SPAWN_CHANCE = 0.07;
        
        // --- Sound Engine ---
        const sounds = {
            swipe: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
            clean: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination(),
            error: new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination(),
            powerUp: new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.2, release: 0.3 } }).toDestination(),
            starCollect: new Tone.Synth({ oscillator: {type: 'triangle'}, envelope: { attack: 0.005, decay: 0.1, sustain: 0.02, release: 0.1}}).toDestination(),
            buttonClick: new Tone.Synth({ oscillator: {type: "sine"}, envelope: {attack: 0.005, decay: 0.1, sustain: 0, release: 0.1}}).toDestination(),
            itemCollect: new Tone.Synth({ oscillator: { type: "triangle8" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.2 } }).toDestination(),
        };
        Object.values(sounds).forEach(sound => sound.volume.value = -8);
        sounds.powerUp.volume.value = -3;
        sounds.starCollect.volume.value = -6;

        // --- Canvas & UI Sizing ---
        function resizeCanvas() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);

        // --- GameObject Definitions ---
        const GameObjectType = {
            POLLUTANT_PLASTIC: 'plastic', POLLUTANT_FUME: 'fume', POLLUTANT_OIL: 'oil',
            PROTECTED_SAPLING: 'sapling', PROTECTED_WATER: 'water',
            ITEM_SLOW_MOTION: 'item_slow_motion', ITEM_SHIELD: 'item_shield',
            ITEM_SCORE_MULTIPLIER: 'item_score_multiplier', ITEM_ENERGY_BOOST: 'item_energy_boost',
            BONUS_STAR: 'star',
        };
        const POLLUTANT_TYPES = [GameObjectType.POLLUTANT_PLASTIC, GameObjectType.POLLUTANT_FUME, GameObjectType.POLLUTANT_OIL];
        const PROTECTED_TYPES = [GameObjectType.PROTECTED_SAPLING, GameObjectType.PROTECTED_WATER];
        const ITEM_TYPES = [GameObjectType.ITEM_SLOW_MOTION, GameObjectType.ITEM_SHIELD, GameObjectType.ITEM_SCORE_MULTIPLIER, GameObjectType.ITEM_ENERGY_BOOST];

        class GameObject {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.isItem = ITEM_TYPES.includes(type);
                this.isStar = type === GameObjectType.BONUS_STAR;
                this.radius = Math.random() * 10 + (this.isItem ? 25 : (this.isStar ? 15 : 30));
                
                this.vx = (Math.random() - 0.5) * (this.isStar ? 1 : 2);
                this.vy = (Math.random() - 0.5) * (this.isStar ? 1 : 2);
                this.gravity = 0.05;
                
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * (this.isStar ? 0.1 : 0.05);
                this.isHit = false; this.alpha = 1;
            }
            update() {
                const slowMoFactor = isSlowMotionActive ? 0.3 : 1;
                this.vy += this.gravity * slowMoFactor;
                this.x += this.vx * slowMoFactor;
                this.y += this.vy * slowMoFactor;
                this.rotation += this.rotationSpeed * slowMoFactor;
                if (this.isHit) this.alpha -= 0.15; // Stars fade faster
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.alpha;
                drawShape(this.type, this.radius, ctx, false);
                ctx.restore();
            }
        }
        
        // --- Core Game Logic ---

        function showTemporaryMessage(message, duration, color = 'white') {
            const msgElement = document.createElement('div');
            msgElement.textContent = message;
            Object.assign(msgElement.style, {
                position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)',
                fontSize: 'clamp(1.5rem, 5vw, 2.2rem)', fontWeight: 'bold', color: color,
                backgroundColor: 'rgba(0,0,0,0.75)', padding: '25px', borderRadius: '15px',
                zIndex: '200', textShadow: '2px 2px 5px black', boxShadow: '0 0 20px rgba(255,255,255,0.3)',
                textAlign: 'center', pointerEvents: 'none'
            });
            gameContainer.appendChild(msgElement);
            setTimeout(() => { if (gameContainer.contains(msgElement)) gameContainer.removeChild(msgElement); }, duration);
        }
        
        function initGame() {
            score = 0; lives = 3; energy = 0; bonusLevel = 1;
            gameSpeedMultiplier = 1; currentSpawnInterval = baseSpawnInterval;
            gameObjects = []; particles = []; swipePath = [];
            isSwiping = false; 
            isSlowMotionActive = false; isShieldActive = false; isScoreMultiplierActive = false;
            
            bonusTimerDisplay.style.display = 'none';
            gameContainer.style.background = `linear-gradient(180deg, #56ab2f 0%, #a8e063 100%)`;
            updateUI(Date.now());
            resizeCanvas();
        }

        function gameLoop() {
            const currentTime = Date.now();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'playing') {
                updateItemEffects(currentTime);
                const slowMoFactor = isSlowMotionActive ? 0.3 : 1;
                
                if (currentTime - lastSpawnTime > currentSpawnInterval / slowMoFactor) {
                    spawnGameObject();
                    lastSpawnTime = currentTime;
                }
            } else if (gameState === 'bonusTime') {
                if (currentTime >= bonusTimeEndTime) {
                    gameState = 'playing';
                    bonusLevel++;
                    gameObjects = []; // Clear leftover stars
                    bonusTimerDisplay.style.display = 'none';
                    gameContainer.style.background = `linear-gradient(180deg, #56ab2f 0%, #a8e063 100%)`;
                } else {
                    const remainingTime = Math.ceil((bonusTimeEndTime - currentTime) / 1000);
                    bonusTimerDisplay.textContent = remainingTime;

                    // MECHANIC CHANGE: Spawn stars in bursts that increase with bonusLevel
                    const baseSpawnChance = 0.35; 
                    if (Math.random() < baseSpawnChance) {
                        const starsInBurst = 1 + Math.floor(bonusLevel / 2); // Lvl 1-2: 1 star, 3-4: 2 stars, etc.
                        for (let i = 0; i < starsInBurst; i++) {
                            const xOffset = (Math.random() - 0.5) * 80; // Spawn in a cluster
                            const star = new GameObject(canvas.width / 2 + xOffset, -60, GameObjectType.BONUS_STAR);
                            star.vy = (Math.random() * 2 + 4); // A bit faster
                            gameObjects.push(star);
                        }
                    }
                }
            }

            if (gameState === 'playing' || gameState === 'bonusTime') {
                gameObjects.forEach(obj => { obj.update(); obj.draw(); });
                gameObjects = gameObjects.filter(obj => obj.y < canvas.height + 100 && obj.x > -100 && obj.x < canvas.width + 100 && obj.alpha > 0);

                particles.forEach(p => { p.update(); p.draw(); });
                particles = particles.filter(p => p.life > 0);

                if (isSwiping) drawSwipeTrail();
                updateUI(currentTime);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function triggerBonusTime() {
            gameState = 'bonusTime';
            // DURATION CHANGE: Set bonus time to 5 seconds
            bonusTimeEndTime = Date.now() + 5000;
            energy = 0;
            gameObjects = [];
            particles = [];
            
            showTemporaryMessage("çå‹µæ™‚é–“ï¼", 2000, '#FFD700');
            playSound(sounds.powerUp, 600, 1.0);
            
            bonusTimerDisplay.style.display = 'block';
            gameContainer.style.background = `linear-gradient(180deg, #141E30 0%, #243B55 100%)`;
            updateUI(Date.now());
        }

        function lineCircleIntersection(p1, p2, circle) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const lenSq = dx * dx + dy * dy;
            if (lenSq === 0) { 
                return Math.pow(circle.x - p1.x, 2) + Math.pow(circle.y - p1.y, 2) < circle.radius * circle.radius;
            }
            const t = ((circle.x - p1.x) * dx + (circle.y - p1.y) * dy) / lenSq;
            const tClamped = Math.max(0, Math.min(1, t));
            const closestX = p1.x + tClamped * dx;
            const closestY = p1.y + tClamped * dy;
            const distSq = Math.pow(circle.x - closestX, 2) + Math.pow(circle.y - closestY, 2);
            return distSq < circle.radius * circle.radius;
        }

        function handleSwipeInteraction(x, y) {
            const p2 = { x, y };
            const p1 = swipePath.length > 1 ? swipePath[swipePath.length - 2] : p2;

            for (let i = gameObjects.length - 1; i >= 0; i--) {
                const obj = gameObjects[i];
                if (obj.isHit) continue;
                if (lineCircleIntersection(p1, p2, obj)) {
                    obj.isHit = true;
                    if (obj.type === GameObjectType.BONUS_STAR) {
                         // SCORE CHANGE: Set star score to 0.5
                         addScore(0.5);
                         playSound(sounds.starCollect, 600 + Math.random() * 400);
                         createBurstParticles(obj.x, obj.y, '#FFD700', 10, 5);
                    } else if (POLLUTANT_TYPES.includes(obj.type)) {
                        addScore(10); addEnergy(5); playSound(sounds.clean, 400 + Math.random() * 200);
                        createBurstParticles(obj.x, obj.y, '#76FF03', 15, 8);
                    } else if (ITEM_TYPES.includes(obj.type)) {
                        activateItemEffect(obj.type, {x, y});
                    } else if (PROTECTED_TYPES.includes(obj.type)) {
                        handleMistake(obj.x, obj.y);
                    }
                    return;
                }
            }
        }
        
        const styleSheet = document.createElement("style");
        styleSheet.innerText = `@keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 50%, 90% { transform: translateX(-6px); } 30%, 70% { transform: translateX(6px); } } .animate-shake { animation: shake 0.35s cubic-bezier(.36,.07,.19,.97) both; }`;
        document.head.appendChild(styleSheet);
        
        function handleMistake(x, y) {
             if (isShieldActive) {
                isShieldActive = false; playSound(sounds.itemCollect, 300, 0.3); createBurstParticles(x, y, '#4DB6AC', 20, 8);
            } else {
                lives--; playSound(sounds.error, 150, 0.2); createBurstParticles(x, y, '#EF5350', 20, 8);
                gameContainer.classList.add('animate-shake'); setTimeout(() => gameContainer.classList.remove('animate-shake'), 300);
                if (lives <= 0) triggerGameOver();
            }
        }
        
        function playSound(soundNode, freqOrNull, duration = 0.1) {
            if (Tone.context.state !== 'running') Tone.start().catch(e => console.warn("Tone.start() failed:", e));
            try {
                if(soundNode.state === "started" && soundNode.name !== "Synth") return;
                if (soundNode.name === "NoiseSynth" || soundNode.name === "MembraneSynth") soundNode.triggerAttackRelease(duration);
                else if (freqOrNull !== null) soundNode.triggerAttackRelease(freqOrNull, duration);
            } catch (e) { /* console.warn("Error playing sound:", e); */ }
        }
        
        function spawnGameObject() {
            let numToSpawn = Math.min(4, 1 + Math.floor(score / 500));
            for (let k = 0; k < numToSpawn; k++) {
                let type;
                if (Math.random() < ITEM_SPAWN_CHANCE) { type = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)]; } 
                else { type = Math.random() < 0.6 ? POLLUTANT_TYPES[Math.floor(Math.random() * POLLUTANT_TYPES.length)] : PROTECTED_TYPES[Math.floor(Math.random() * PROTECTED_TYPES.length)]; }
                
                const x = Math.random() * canvas.width;
                const y = -60;
                const newObj = new GameObject(x, y, type);
                
                const speedFactor = 0.1 + (energy / maxEnergy) * 1.0;
                const baseSpeed = (newObj.isItem ? 0.5 : 0.8) * gameSpeedMultiplier * speedFactor;
                
                newObj.vy = (Math.random() * 0.4 + 0.6) * baseSpeed;
                newObj.vx = (Math.random() - 0.5) * baseSpeed;
                
                gameObjects.push(newObj);
            }
        }

        function addScore(points) { score += points * (isScoreMultiplierActive ? 2 : 1); gameSpeedMultiplier = Math.min(2.5, 1 + score / 1000); currentSpawnInterval = Math.max(300, baseSpawnInterval - (score / 20)); }
        
        function addEnergy(amount) {
            if (gameState !== 'playing' || energy >= maxEnergy) return; 
            const oldEnergy = energy;
            energy = Math.min(energy + amount, maxEnergy);
            
            if (oldEnergy < maxEnergy && energy >= maxEnergy) {
                triggerBonusTime();
            }
            updateUI(Date.now());
        }
        
        function updateUI(currentTime) {
            scoreDisplay.textContent = `åˆ†æ•¸: ${Math.floor(score)}`; livesDisplay.textContent = `ç”Ÿå‘½: ${lives}`;
            const energyPercentage = (energy / maxEnergy) * 100;
            energyBar.style.width = `${energyPercentage}%`;
            energyText.textContent = energyPercentage >= 15 ? `èƒ½é‡: ${Math.floor(energyPercentage)}%` : '';
            energyBar.classList.toggle('full', energyPercentage >= 100);
            
            shieldStatus.style.display = isShieldActive ? 'flex' : 'none';
            
            if (isSlowMotionActive) {
                slowmoStatus.style.display = 'flex';
                const time = Math.ceil((slowMotionEndTime - currentTime)/1000);
                slowmoStatus.textContent = time > 0 ? `â³ ${time}` : '';
            } else { slowmoStatus.style.display = 'none'; }

            if (isScoreMultiplierActive) {
                multiplierStatus.style.display = 'flex';
                 const time = Math.ceil((scoreMultiplierEndTime - currentTime)/1000);
                multiplierStatus.textContent = time > 0 ? `x2 ${time}` : '';
            } else { multiplierStatus.style.display = 'none'; }
        }
        
        function updateItemEffects(currentTime) {
            if (isSlowMotionActive && currentTime > slowMotionEndTime) isSlowMotionActive = false;
            if (isScoreMultiplierActive && currentTime > scoreMultiplierEndTime) isScoreMultiplierActive = false;
        }

        function activateItemEffect(itemType, position) {
            const currentTime = Date.now();
            playSound(sounds.itemCollect, 600); createBurstParticles(position.x, position.y, '#FFD700', 25, 10);
            switch (itemType) {
                case GameObjectType.ITEM_SLOW_MOTION: isSlowMotionActive = true; slowMotionEndTime = currentTime + SLOW_MOTION_DURATION; showTemporaryMessage("æ™‚é–“ç·©ç·©ï¼", 2000, '#B0BEC5'); break;
                case GameObjectType.ITEM_SHIELD: isShieldActive = true; showTemporaryMessage("å®ˆè­·å…‰ç›¾ï¼", 2000, '#4DB6AC'); break;
                case GameObjectType.ITEM_SCORE_MULTIPLIER: isScoreMultiplierActive = true; scoreMultiplierEndTime = currentTime + SCORE_MULTIPLIER_DURATION; showTemporaryMessage("é›™å€ç©åˆ†ï¼", 2000, '#FFD54F'); break;
                case GameObjectType.ITEM_ENERGY_BOOST: addEnergy(40); showTemporaryMessage("èƒ½é‡è£œå……ï¼", 1500, '#FFEE58'); break;
            }
            updateUI(currentTime);
        }

        class Particle {
            constructor(x, y, color, size, life) { this.x = x; this.y = y; this.size = Math.random() * size + 2; this.color = color; this.life = life || Math.random() * 60 + 40; this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.alpha = 1; this.gravity = 0.05; }
            update() { 
                const slowMoFactor = isSlowMotionActive ? 0.3 : 1;
                this.vy += this.gravity * slowMoFactor; 
                this.x += this.vx * slowMoFactor; 
                this.y += this.vy * slowMoFactor; 
                this.life--; 
                this.alpha = this.life / 60;
            }
            draw() { ctx.globalAlpha = Math.max(0, this.alpha); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
        }
        function createBurstParticles(x, y, color, count, size = 5, life = 50) { for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color, size, life)); }
        
        function drawSwipeTrail() {
            if (swipePath.length < 2) return;
            ctx.strokeStyle = `rgba(255, 236, 179, 0.7)`;
            ctx.lineWidth = 12; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.shadowColor = `rgba(255, 215, 0, 0.7)`; ctx.shadowBlur = 15; ctx.beginPath();
            ctx.moveTo(swipePath[0].x, swipePath[0].y);
            for (let i = 1; i < swipePath.length; i++) { ctx.lineTo(swipePath[i].x, swipePath[i].y); }
            ctx.stroke(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
        }
        
        function switchScreen(activeScreen) { [startScreen, gameOverScreen, pauseScreen, howToPlayScreen].forEach(s => s.classList.remove('active')); if (activeScreen) activeScreen.classList.add('active'); }
        function startGameFlow() { initGame(); gameState = 'playing'; switchScreen(null); if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(gameLoop); }
        function triggerGameOver() { gameState = 'gameOver'; finalScoreDisplay.textContent = `ä½ çš„æœ€çµ‚åˆ†æ•¸: ${Math.floor(score)}`; switchScreen(gameOverScreen); playSound(sounds.error, 80, 0.6); bonusTimerDisplay.style.display = 'none'; }
        
        function pauseGame() {
            if (gameState === 'playing' || gameState === 'bonusTime') {
                pausedTime = Date.now();
                prePauseGameState = gameState;
                gameState = 'paused';
                cancelAnimationFrame(animationFrameId);
                
                switchScreen(pauseScreen);
                if (prePauseGameState === 'bonusTime') {
                    bonusTimerDisplay.style.display = 'none';
                }
            }
        }
        function resumeGame() {
            if (gameState === 'paused') {
                const timePaused = Date.now() - pausedTime;
                
                if (isSlowMotionActive) slowMotionEndTime += timePaused;
                if (isScoreMultiplierActive) scoreMultiplierEndTime += timePaused;
                
                gameState = prePauseGameState;

                if (gameState === 'bonusTime') {
                    bonusTimeEndTime += timePaused;
                    bonusTimerDisplay.style.display = 'block';
                }
                
                switchScreen(null);
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }
        
        function handleMouseDown(e) { if (gameState !== 'playing' && gameState !== 'bonusTime') return; isSwiping = true; const rect = canvas.getBoundingClientRect(); swipePath = [{ x: e.clientX - rect.left, y: e.clientY - rect.top }]; playSound(sounds.swipe, 300, 0.05); }
        function handleMouseMove(e) { if (!isSwiping) return; const rect = canvas.getBoundingClientRect(); const newPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top }; swipePath.push(newPoint); if(swipePath.length > 20) swipePath.shift(); handleSwipeInteraction(newPoint.x, newPoint.y); }
        function handleMouseUp(e) { isSwiping = false; }
        function handleTouchStart(e) { if (gameState !== 'playing' && gameState !== 'bonusTime') return; e.preventDefault(); const touch = e.touches[0]; const rect = canvas.getBoundingClientRect(); isSwiping = true; swipePath = [{ x: touch.clientX - rect.left, y: touch.clientY - rect.top }]; playSound(sounds.swipe, 300, 0.05); }
        function handleTouchMove(e) { if (!isSwiping) return; e.preventDefault(); const touch = e.touches[0]; const rect = canvas.getBoundingClientRect(); const newPoint = { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; swipePath.push(newPoint); if(swipePath.length > 20) swipePath.shift(); handleSwipeInteraction(newPoint.x, newPoint.y); }
        function handleTouchEnd(e) { isSwiping = false; }
        
        gameContainer.addEventListener('contextmenu', e => e.preventDefault());
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', () => isSwiping = false);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        
        document.querySelectorAll('.action-button').forEach(button => button.addEventListener('click', () => playSound(sounds.buttonClick, 500)));
        startButton.addEventListener('click', startGameFlow);
        restartButton.addEventListener('click', startGameFlow);
        pauseButton.addEventListener('click', pauseGame);
        resumeButton.addEventListener('click', resumeGame);
        quitButton.addEventListener('click', () => { switchScreen(startScreen); initGame(); gameState = 'start'; if (animationFrameId) cancelAnimationFrame(animationFrameId); });
        howToPlayButton.addEventListener('click', () => switchScreen(howToPlayScreen));
        closeHowToPlayButton.addEventListener('click', () => switchScreen(startScreen));
        
        function drawShape(type, radius, c, isIcon) {
            c.beginPath(); const lineWidth = isIcon ? 1.5 : 2.5;
            switch (type) {
                case GameObjectType.POLLUTANT_PLASTIC: case 'plastic_icon':
                    c.fillStyle = '#89B0AE'; c.strokeStyle = '#5F7A7A'; c.lineWidth = lineWidth;
                    c.moveTo(-radius * 0.5, radius * 0.9); c.lineTo(-radius * 0.6, -radius * 0.4); c.quadraticCurveTo(-radius * 0.6, -radius * 0.6, -radius * 0.4, -radius * 0.7);
                    c.lineTo(radius * 0.4, -radius * 0.7); c.quadraticCurveTo(radius * 0.6, -radius * 0.6, radius * 0.6, -radius * 0.4); c.lineTo(radius * 0.5, radius * 0.9);
                    c.closePath(); c.fill(); c.stroke(); c.fillStyle = '#5F7A7A'; c.fillRect(-radius * 0.4, -radius, radius*0.8, radius * 0.3); break;
                case GameObjectType.POLLUTANT_FUME: case 'fume_icon':
                    c.fillStyle = '#6B7280'; c.strokeStyle = '#4B5563'; c.lineWidth = isIcon ? 1 : 2;
                    c.arc(0, 0, radius * 0.7, 0, Math.PI * 2); c.arc(radius * 0.5, radius * 0.3, radius * 0.5, 0, Math.PI * 2);
                    c.arc(-radius * 0.4, radius * 0.2, radius * 0.6, 0, Math.PI * 2); c.arc(0, -radius * 0.4, radius * 0.5, 0, Math.PI * 2); c.fill(); break;
                case GameObjectType.POLLUTANT_OIL: case 'oil_icon':
                    c.fillStyle = '#3A3A3A'; c.strokeStyle = '#1A1A1A'; c.lineWidth = lineWidth;
                    c.moveTo(0, -radius * 0.5); c.bezierCurveTo(radius, -radius, radius, radius, 0, radius); c.bezierCurveTo(-radius, radius, -radius, -radius * 0.8, 0, -radius * 0.5);
                    c.fill(); c.stroke(); c.fillStyle = 'rgba(255, 255, 255, 0.4)'; c.beginPath(); c.arc(-radius * 0.3, -radius * 0.2, radius * 0.25, 0, Math.PI * 2); c.fill(); break;
                case GameObjectType.PROTECTED_SAPLING: case 'sapling_icon':
                    c.fillStyle = '#8D6E63'; c.strokeStyle = '#5D4037'; c.lineWidth = lineWidth; c.beginPath(); c.rect(-radius * 0.15, 0, radius * 0.3, radius); c.fill(); c.stroke();
                    c.fillStyle = '#66BB6A'; c.strokeStyle = '#388E3C'; c.beginPath(); c.arc(0, -radius * 0.3, radius * 0.7, Math.PI, Math.PI * 2); c.closePath(); c.fill(); c.stroke(); break;
                case GameObjectType.PROTECTED_WATER: case 'water_icon':
                    c.fillStyle = '#4FC3F7'; c.strokeStyle = '#03A9F4'; c.lineWidth = lineWidth;
                    c.moveTo(0, -radius); c.bezierCurveTo(radius * 1.3, -radius * 0.8, radius * 0.8, radius, 0, radius); c.bezierCurveTo(-radius * 0.8, radius, -radius * 1.3, -radius * 0.8, 0, -radius);
                    c.fill(); c.stroke(); break;
                case GameObjectType.BONUS_STAR: case 'star_icon':
                case GameObjectType.ITEM_SCORE_MULTIPLIER: case 'multi_icon':
                    c.fillStyle = '#FFD54F'; c.strokeStyle = '#FFB300'; c.lineWidth = isIcon ? 1.5 : 2; c.beginPath();
                    for (let i = 0; i < 5; i++) { c.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * radius, -Math.sin((18 + i * 72) / 180 * Math.PI) * radius); c.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * radius * 0.5, -Math.sin((54 + i * 72) / 180 * Math.PI) * radius * 0.5); }
                    c.closePath(); c.fill(); c.stroke();
                    if(type === 'multi_icon' && !isIcon) { c.fillStyle = '#BF360C'; c.font = `bold ${radius*0.7}px Arial`; c.textAlign = 'center'; c.textBaseline = 'middle'; c.fillText('x2', 0, radius*0.1); } break;
                case GameObjectType.ITEM_SLOW_MOTION: case 'slowmo_icon':
                    c.fillStyle = '#B0BEC5'; c.strokeStyle = '#78909C'; c.lineWidth = isIcon ? 1.5 : 2; c.arc(0, 0, radius, 0, Math.PI * 2); c.fill(); c.stroke();
                    c.beginPath(); c.fillStyle = '#546E7A'; c.moveTo(0,0); c.lineTo(0, -radius * 0.7); c.moveTo(0,0); c.lineTo(radius * 0.5, 0); c.stroke(); break;
                case GameObjectType.ITEM_SHIELD: case 'shield_icon':
                    c.fillStyle = '#4DB6AC'; c.strokeStyle = '#00897B'; c.lineWidth = isIcon ? 1.5 : 2;
                    c.moveTo(0, -radius); c.quadraticCurveTo(radius, -radius * 0.5, radius, 0); c.quadraticCurveTo(radius, radius * 0.8, 0, radius);
                    c.quadraticCurveTo(-radius, radius * 0.8, -radius, 0); c.quadraticCurveTo(-radius, -radius * 0.5, 0, -radius); c.fill(); c.stroke(); break;
                case GameObjectType.ITEM_ENERGY_BOOST: case 'energy_icon':
                    c.fillStyle = '#FFEE58'; c.strokeStyle = '#FDD835'; c.lineWidth = isIcon ? 1.5 : 2;
                    c.moveTo(-radius * 0.2, -radius); c.lineTo(radius * 0.3, -radius * 0.1); c.lineTo(0, -radius * 0.1);
                    c.lineTo(radius * 0.2, radius); c.lineTo(-radius * 0.3, -radius * 0.2); c.lineTo(0, -radius * 0.2); c.closePath(); c.fill(); c.stroke(); break;
                default: c.fillStyle = 'magenta'; c.arc(0,0,radius,0,Math.PI*2); c.fill(); break;
            }
        }

        document.querySelectorAll('.item-icon-canvas').forEach(iconCanvas => {
            const iconCtx = iconCanvas.getContext('2d');
            iconCtx.width = 22; iconCtx.height = 22;
            iconCtx.clearRect(0,0,22,22); iconCtx.save();
            iconCtx.translate(11, 11);
            drawShape(iconCanvas.dataset.type, 9, iconCtx, true);
            iconCtx.restore();
        });

        // --- Initial Load ---
        switchScreen(startScreen);
        resizeCanvas();
        
    </script>
</body>
</html>
