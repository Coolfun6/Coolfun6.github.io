<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç’°ä¿ç‰¹æ”»éšŠï¼šæ·¨åŒ–å…ˆé‹’</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            overflow: hidden;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            color: white;
            -webkit-tap-highlight-color: transparent;
        }
        #game-container {
            width: 100%;
            max-width: 450px;
            height: 100%;
            max-height: 850px;
            background: linear-gradient(180deg, #56ab2f 0%, #a8e063 100%);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            border-radius: 25px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 3px solid rgba(255,255,255,0.2);
            transition: background 0.5s ease, filter 0.5s ease;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            background-color: transparent;
            position: absolute;
            top: 0;
            left: 0;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
            z-index: 10;
        }
        .top-ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }
        .status-icons {
            display: flex;
            gap: 8px;
            user-select: none;
        }
        .status-icon {
            width: 30px;
            height: 30px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 1px 1px 2px black;
        }
        .bottom-ui {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            pointer-events: auto;
            flex-direction: column;
        }
        .score-display, .lives-display {
            font-size: clamp(1rem, 3.5vw, 1.4rem); 
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 10px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.3);
        }
        #energy-bar-container {
            width: 100%;
            height: 28px; 
            background-color: rgba(0,0,0,0.4);
            border-radius: 14px;
            margin-top: 8px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.6);
            position: relative;
        }
        #energy-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #66BB6A, #AED581, #81C784, #AED581, #66BB6A);
            background-size: 300% 100%;
            animation: animated-gradient-subtle 4s ease infinite;
            border-radius: 11px 0 0 11px;
            transition: width 0.3s ease-in-out, background 0.3s ease-in-out, border-radius 0.1s linear;
        }
        .bar-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #energy-text {
            font-size: 0.9rem;
        }
        #energy-bar.full {
            background: linear-gradient(90deg, #FFD700, #FFB300, #FF8F00, #FFB300, #FFD700);
            background-size: 300% 100%;
            animation: animated-gradient-active 3s ease infinite, pulse-gold-shadow 1.5s infinite;
            border-radius: 11px;
        }
        
        @keyframes animated-gradient-subtle { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        @keyframes animated-gradient-active { 0% { background-position: 200% 50%; } 50% { background-position: -100% 50%; } 100% { background-position: 200% 50%; } }
        @keyframes pulse-gold-shadow { 0% { box-shadow: 0 0 3px #FFD700, 0 0 5px #FFB300; } 50% { box-shadow: 0 0 10px 3px #FFD700, 0 0 15px 5px #FFB300; } 100% { box-shadow: 0 0 3px #FFD700, 0 0 5px #FFB300; } }

        #start-screen, #game-over-screen, #pause-screen, #how-to-play-screen, #win-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; z-index: 100; padding: 20px;
            backdrop-filter: blur(10px); 
            opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #start-screen.active, #game-over-screen.active, #pause-screen.active, #how-to-play-screen.active, #win-screen.active {
            opacity: 1; visibility: visible;
        }
        .screen-title {
            font-size: clamp(2rem, 8vw, 2.8rem); 
            font-weight: bold; margin-bottom: 20px;
            color: #A7F3D0; 
            text-shadow: 0 0 8px #A7F3D0, 0 0 15px #A7F3D0, 2px 2px 4px rgba(0,0,0,0.7);
        }
        #win-screen .screen-title { color: #FFD700; text-shadow: 0 0 8px #FFD700, 0 0 15px #FFB700, 2px 2px 4px rgba(0,0,0,0.7); }
        .screen-text, .how-to-play-content p, .how-to-play-content li { font-size: clamp(0.9rem, 3vw, 1.1rem); margin-bottom: 12px; line-height: 1.5; }
        .how-to-play-content { max-height: 65vh; overflow-y: auto; padding-right: 10px; text-align: left; }
        .how-to-play-content h3 { font-size: clamp(1.1rem, 3.5vw, 1.4rem); color: #FFEB3B; margin-top: 18px; margin-bottom: 8px; }

        .action-button {
            padding: 10px 22px; font-size: clamp(1rem, 3.8vw, 1.2rem); font-weight: bold; color: #1A202C;
            background: linear-gradient(135deg, #81C784 0%, #A5D6A7 100%);
            border: none; border-radius: 10px; cursor: pointer; transition: all 0.2s ease-in-out;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2), inset 0 -2px 2px rgba(0,0,0,0.1);
            margin-top: 8px;
        }
        .action-button:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 12px rgba(0,0,0,0.3), inset 0 -2px 2px rgba(0,0,0,0.1); filter: brightness(1.1); }
        .action-button:active { transform: translateY(0px) scale(0.98); box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 -1px 1px rgba(0,0,0,0.1); }
        .button-secondary { background: linear-gradient(135deg, #FFB74D 0%, #FF9800 100%); }
        .button-danger { background: linear-gradient(135deg, #E57373 0%, #F44336 100%); }

        .boss-ui-container {
            position: absolute; top: 50px; left: 50%;
            transform: translateX(-50%);
            width: 85%;
            display: flex; flex-direction: column;
            align-items: center; gap: 8px;
            z-index: 15;
            pointer-events: none;
        }
        #boss-health-container, #boss-timer-container {
            width: 100%; height: 30px;
            background-color: rgba(0,0,0,0.6); border-radius: 15px;
            overflow: hidden; display: none;
            position: relative;
        }
        #boss-health-container { border: 2.5px solid #B71C1C; }
        #boss-timer-container { border: 2.5px solid #4FC3F7; height: 18px; }
        #boss-health-bar, #boss-timer-bar {
            width: 100%; height: 100%;
            border-radius: 12px 0 0 12px;
            transition: width 0.2s linear;
        }
        #boss-health-bar { background: linear-gradient(90deg, #C62828, #F44336, #EF5350); }
        #boss-timer-bar { background: linear-gradient(90deg, #29B6F6, #4FC3F7, #81D4FA); }
        #boss-health-text { font-size: 1rem; }
        #boss-timer-text { font-size: 0.8rem; }
        
        #pause-button {
            font-size: clamp(1.2rem, 4.5vw, 1.6rem); background-color: rgba(0,0,0,0.5);
            padding: 7px 12px; border-radius: 8px; cursor: pointer; user-select: none;
            border: 1px solid rgba(255,255,255,0.3); transition: background-color 0.2s;
        }
        #pause-button:hover { background-color: rgba(0,0,0,0.7); }
        .item-icon-canvas { display: inline-block; width: 22px; height: 22px; margin-right: 6px; vertical-align: middle; border: 1px solid #ccc; border-radius: 4px; background: #334; }
        #swipe-line {
            position: absolute;
            bottom: 65px;
            left: 5%;
            width: 90%;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 1px;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="swipe-line"></div>
        
        <div class="ui-overlay">
            <div class="top-ui">
                <div id="score" class="score-display">åˆ†æ•¸: 0</div>
                <div class="status-icons">
                    <div id="shield-status" class="status-icon" style="display: none;">ğŸ›¡ï¸</div>
                    <div id="multiplier-status" class="status-icon" style="display: none;">x2</div>
                </div>
                <div id="pause-button">II</div>
                <div id="lives" class="lives-display">ç”Ÿå‘½: 3</div>
            </div>
            <div class="boss-ui-container">
                <div id="boss-health-container">
                    <div id="boss-health-bar"></div>
                    <div id="boss-health-text" class="bar-text">é­”ç‹è¡€é‡</div>
                </div>
                <div id="boss-timer-container">
                    <div id="boss-timer-bar"></div>
                    <div id="boss-timer-text" class="bar-text">æ™‚é–“</div>
                </div>
            </div>
            <div class="bottom-ui">
                 <div id="energy-bar-container">
                    <div id="energy-bar"></div>
                    <div id="energy-text" class="bar-text">èƒ½é‡</div>
                </div>
            </div>
        </div>


        <div id="start-screen" class="active">
            <h1 class="screen-title">ç’°ä¿ç‰¹æ”»éšŠ</h1>
            <p class="screen-text">æ»‘å‹•æ‰‹æŒ‡ï¼Œæ·¨åŒ–æ±¡æŸ“ç‰©ï¼Œæ“Šæ•—ä¸‰å¤§æ±¡æŸ“é­”ç‹ï¼</p>
            <button id="start-button" class="action-button">ğŸš€ é–‹å§‹éŠæˆ²</button>
            <button id="how-to-play-button" class="action-button button-secondary mt-4">ğŸ“– éŠæˆ²ç©æ³•</button>
        </div>

        <div id="game-over-screen">
            <h1 class="screen-title">éŠæˆ²çµæŸ</h1>
            <p id="final-score" class="screen-text">ä½ çš„æœ€çµ‚åˆ†æ•¸: 0</p>
            <button id="restart-button" class="action-button">ğŸ”„ é‡æ–°é–‹å§‹</button>
        </div>
        
        <div id="win-screen">
            <h1 class="screen-title">æ­å–œç²å‹ï¼</h1>
            <p class="screen-text">ä½ å·²æˆåŠŸæ·¨åŒ–æ‰€æœ‰æ±¡æŸ“æºï¼Œåœ°çƒæ„Ÿè¬ä½ ï¼</p>
            <p id="win-final-score" class="screen-text">ä½ çš„æœ€çµ‚åˆ†æ•¸: 0</p>
            <button id="play-again-button" class="action-button">ğŸŒ å†ç©ä¸€æ¬¡</button>
        </div>

        <div id="pause-screen">
            <h1 class="screen-title">éŠæˆ²æš«åœ</h1>
            <button id="resume-button" class="action-button">â–¶ï¸ ç¹¼çºŒéŠæˆ²</button>
            <button id="quit-button" class="action-button button-danger mt-4">ğŸšª çµæŸéŠæˆ²</button>
        </div>

        <div id="how-to-play-screen">
            <h1 class="screen-title">éŠæˆ²ç©æ³•èªªæ˜</h1>
            <div class="how-to-play-content">
                <p>ä½ çš„ä»»å‹™æ˜¯æ¸…é™¤æ±¡æŸ“ï¼Œä¾åºæ“Šæ•—ä¸‰ä½å¼·å¤§çš„ã€Œæ±¡æŸ“é­”ç‹ã€ï¼Œå¾¹åº•å®ˆè­·åœ°çƒã€‚</p>
                <h3>âš¡ èƒ½é‡èˆ‡é­”ç‹æŒ‘æˆ°ï¼š</h3>
                <ul>
                    <li>æ·¨åŒ–æ±¡æŸ“ç‰©å¯ç´¯ç©åº•éƒ¨ã€Œèƒ½é‡æ¢ã€ã€‚</li>
                    <li>èƒ½é‡æ¢é›†æ»¿æ™‚ï¼Œæœƒ**è‡ªå‹•è§¸ç™¼**é­”ç‹æˆ°ï¼</li>
                </ul>
                 <h3 style="color: #FFCC80;">ğŸ‘¹ é­”ç‹æˆ°ï¼šé™æ™‚æŒ‘æˆ°ï¼ğŸ‘¹</h3>
                <ul>
                    <li>é­”ç‹å‡ºç¾æ™‚ï¼Œç•«é¢ä¸Šæ–¹æœƒå‡ºç¾**å€’æ•¸è¨ˆæ™‚æ¢**ï¼</li>
                    <li>ä½ å¿…é ˆåœ¨æ™‚é™å…§æ“Šæ•—é­”ç‹ã€‚è‹¥æ™‚é–“è€—ç›¡é­”ç‹å°‡æœƒé€ƒè·‘ï¼Œä¸¦ä¸”ä½ æœƒ**å¤±å»ä¸€é»ç”Ÿå‘½å€¼**ï¼</li>
                    <li>åœ¨é­”ç‹æˆ°ä¸­ï¼Œèƒ½é‡æ¢é›†æ»¿æ™‚æœƒ**è‡ªå‹•æ–½æ”¾**ä¸€æ¬¡å¼·åŠ›çš„ã€Œ**æ·¨åŒ–è¡æ“Š**ã€ï¼</li>
                </ul>
                <h3>â˜ ï¸ æ±¡æŸ“ç‰© (éœ€è¦æ·¨åŒ–)ï¼š</h3>
                <ul>
                    <li><canvas class="item-icon-canvas" data-type="plastic_icon"></canvas>å¡‘è† ç“¶æ€ªã€<canvas class="item-icon-canvas" data-type="fume_icon"></canvas>å»¢æ°£æ³¡æ³¡ã€<canvas class="item-icon-canvas" data-type="oil_icon"></canvas>æ²¹æ±¡åœ˜å¡Šã€‚</li>
                </ul>
                <h3>ğŸŒ³ ä¿è­·ç‰© (éœ€è¦é¿é–‹)ï¼š</h3>
                <ul>
                    <li><canvas class="item-icon-canvas" data-type="sapling_icon"></canvas>å°æ¨¹è‹—ã€<canvas class="item-icon-canvas" data-type="water_icon"></canvas>ç´”æ·¨æ°´æ»´ã€‚</li>
                </ul>
                <h3>ğŸ é“å…· (æ»‘å‹•ç²å–)ï¼š</h3>
                 <ul>
                    <li><canvas class="item-icon-canvas" data-type="slowmo_icon"></canvas>æ™‚é–“ç·©ç·© (15ç§’)ã€<canvas class="item-icon-canvas" data-type="shield_icon"></canvas>å®ˆè­·å…‰ç›¾ã€<canvas class="item-icon-canvas" data-type="multi_icon"></canvas>é›™å€ç©åˆ†ã€<canvas class="item-icon-canvas" data-type="energy_icon"></canvas>èƒ½é‡è£œå……ã€‚</li>
                </ul>
                <h3>é­”ç‹ä¸€ï¼šæ­¦è£æ±¡æŸ“æ ¸å¿ƒ (æ™‚é™: 60ç§’)</h3>
                <ul>
                    <li><strong>æ–°æ©Ÿåˆ¶ï¼š</strong> é­”ç‹è¢«æ—‹è½‰çš„è­·ç›¾è‡‚ä¿è­·ã€‚ä½ å¿…é ˆæŠ“æº–**ç©ºéš™**æ”»æ“Šæ ¸å¿ƒï¼</li>
                </ul>
                <h3>é­”ç‹äºŒï¼šè…è•å·¨é°» (æ™‚é™: 55ç§’)</h3>
                <ul>
                    <li><strong>æ–°æ©Ÿåˆ¶ï¼š</strong> å·¨é°»èº«é«”ç”±ã€Œè£ç”²ã€å’Œç™¼å…‰çš„ã€Œå¼±é»ã€çµ„æˆã€‚é›†ä¸­ç«åŠ›æ”»æ“Š**å¼±é»**æ‰èƒ½é€ æˆå‚·å®³ï¼</li>
                </ul>
                <h3>é­”ç‹ä¸‰ï¼šè™›å¯¦æ€¨éˆ (æ™‚é™: 65ç§’)</h3>
                <ul>
                    <li>å®ƒæœƒåˆ†èº«æˆæ•¸å€‹å¹»è±¡ï¼Œä½ å¿…é ˆæ‰¾å‡º**é¡è‰²æœ€æ·±**çš„ã€Œæœ¬é«”ã€é€²è¡Œæ”»æ“Šã€‚å®ƒé‚„æœƒé‡‹æ”¾ã€Œæ¿ƒéœ§ã€é®è”½ç•«é¢ï¼Œå¿…é ˆå¿«é€Ÿæ»‘å‹•ä¾†æ¸…é™¤ï¼</li>
                </ul>
                <p>ç¥ä½ å¥½é‹ï¼Œç’°ä¿ç‰¹æ”»éšŠå“¡ï¼</p>
            </div>
            <button id="close-how-to-play-button" class="action-button mt-6">ğŸ‘Œ æˆ‘æ˜ç™½äº†</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const energyBar = document.getElementById('energy-bar');
        const energyBarContainer = document.getElementById('energy-bar-container');
        const energyText = document.getElementById('energy-text');
        const shieldStatus = document.getElementById('shield-status');
        const multiplierStatus = document.getElementById('multiplier-status');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const howToPlayScreen = document.getElementById('how-to-play-screen');
        const winScreen = document.getElementById('win-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const winFinalScoreDisplay = document.getElementById('win-final-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const playAgainButton = document.getElementById('play-again-button');
        const pauseButton = document.getElementById('pause-button');
        const resumeButton = document.getElementById('resume-button');
        const quitButton = document.getElementById('quit-button');
        const howToPlayButton = document.getElementById('how-to-play-button');
        const closeHowToPlayButton = document.getElementById('close-how-to-play-button');
        const bossHealthContainer = document.getElementById('boss-health-container');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossHealthText = document.getElementById('boss-health-text');
        const bossTimerContainer = document.getElementById('boss-timer-container');
        const bossTimerBar = document.getElementById('boss-timer-bar');
        const bossTimerText = document.getElementById('boss-timer-text');

        // --- Game State Variables ---
        let score = 0, lives = 3, energy = 0, level = 1;
        const maxEnergy = 100;
        let gameObjects = [], particles = [], swipePath = [];
        let isSwiping = false, animationFrameId, gameState = 'start';
        let gameSpeedMultiplier = 1, baseSpawnInterval = 1200, currentSpawnInterval = 1200, lastSpawnTime = 0;
        let bossActive = false, boss = null;
        
        // --- Item Effect Timers & Flags ---
        let isSlowMotionActive = false, slowMotionEndTime = 0;
        const SLOW_MOTION_DURATION = 15000;
        let isShieldActive = false;
        let isScoreMultiplierActive = false, scoreMultiplierEndTime = 0;
        const ITEM_EFFECT_DURATION = 7000;
        const ITEM_SPAWN_CHANCE = 0.07;
        
        // --- Sound Engine ---
        const sounds = {
            swipe: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
            clean: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination(),
            error: new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination(),
            powerUp: new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.2, release: 0.3 } }).toDestination(),
            explosion: new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination(),
            bossHit: new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: "exponential"} }).toDestination(),
            buttonClick: new Tone.Synth({ oscillator: {type: "sine"}, envelope: {attack: 0.005, decay: 0.1, sustain: 0, release: 0.1}}).toDestination(),
            itemCollect: new Tone.Synth({ oscillator: { type: "triangle8" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.2 } }).toDestination(),
        };
        Object.values(sounds).forEach(sound => sound.volume.value = -8);
        sounds.powerUp.volume.value = -3;
        sounds.bossHit.volume.value = -3;
        sounds.explosion.volume.value = -4;

        // --- Canvas & UI Sizing ---
        function resizeCanvas() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);

        // --- GameObject Definitions ---
        const GameObjectType = {
            POLLUTANT_PLASTIC: 'plastic', POLLUTANT_FUME: 'fume', POLLUTANT_OIL: 'oil',
            PROTECTED_SAPLING: 'sapling', PROTECTED_WATER: 'water',
            ITEM_SLOW_MOTION: 'item_slow_motion', ITEM_SHIELD: 'item_shield',
            ITEM_SCORE_MULTIPLIER: 'item_score_multiplier', ITEM_ENERGY_BOOST: 'item_energy_boost',
        };
        const POLLUTANT_TYPES = [GameObjectType.POLLUTANT_PLASTIC, GameObjectType.POLLUTANT_FUME, GameObjectType.POLLUTANT_OIL];
        const PROTECTED_TYPES = [GameObjectType.PROTECTED_SAPLING, GameObjectType.PROTECTED_WATER];
        const ITEM_TYPES = [GameObjectType.ITEM_SLOW_MOTION, GameObjectType.ITEM_SHIELD, GameObjectType.ITEM_SCORE_MULTIPLIER, GameObjectType.ITEM_ENERGY_BOOST];

        class GameObject {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.isItem = ITEM_TYPES.includes(type);
                this.radius = Math.random() * 10 + (this.isItem ? 25 : 30);
                
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.gravity = 0.05;
                
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.05;
                this.isHit = false; this.alpha = 1;
            }
            update() {
                const slowMoFactor = isSlowMotionActive ? 0.3 : 1;
                this.vy += this.gravity * slowMoFactor;
                this.x += this.vx * slowMoFactor;
                this.y += this.vy * slowMoFactor;
                this.rotation += this.rotationSpeed * slowMoFactor;
                if (this.isHit) this.alpha -= 0.1;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.alpha;
                drawShape(this.type, this.radius, ctx, false);
                ctx.restore();
            }
        }
        
        // --- BOSS CLASSES (Difficulty Adjusted & Reworked) ---

        class Boss1_PollutionCore {
             constructor() {
                this.name = "æ­¦è£æ±¡æŸ“æ ¸å¿ƒ";
                this.x = canvas.width / 2; this.y = 150;
                this.radius = Math.min(canvas.width / 5, 50);
                this.timeLimit = 60000; this.startTime = Date.now();
                this.maxHealth = 200 + level * 50; this.health = this.maxHealth;
                this.shieldRotation = 0;
                this.shieldArms = 4;
                this.shieldArmLength = this.radius + 60;
                this.shieldArmWidth = 20;
            }
            update(currentTime) {
                this.shieldRotation += 0.01;
                if (this.health <= 0) { bossDefeated(); }
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                
                // Draw rotating shield arms first
                ctx.save();
                ctx.rotate(this.shieldRotation);
                ctx.fillStyle = '#64748B';
                for(let i = 0; i < this.shieldArms; i++) {
                    const angle = (i / this.shieldArms) * Math.PI * 2;
                    ctx.save();
                    ctx.rotate(angle);
                    ctx.fillRect(this.radius, -this.shieldArmWidth / 2, this.shieldArmLength, this.shieldArmWidth);
                    ctx.restore();
                }
                ctx.restore();

                // Draw main body on top
                ctx.fillStyle = '#E53935';
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#B71C1C'; ctx.lineWidth = 4; ctx.stroke();
                
                ctx.restore();
            }
            takeDamage(amount) {
                this.health -= amount; playSound(sounds.bossHit, 250);
                createBurstParticles(this.x, this.y, '#FF5252', 20);
            }
             updateBossHealthDisplay() {
                const percentage = Math.max(0, (this.health / this.maxHealth) * 100);
                bossHealthBar.style.width = `${percentage}%`;
                bossHealthText.textContent = `æ ¸å¿ƒ: ${Math.ceil(percentage)}%`;
            }
        }

        class Boss2_WasteWyrm {
            constructor() {
                this.name = "è…è•å·¨é°»"; this.segmentCount = 5 + level; this.segments = [];
                this.totalHealth = 0; this.maxTotalHealth = 0;
                this.timeLimit = 55000; this.startTime = Date.now();
                this.head = { x: canvas.width / 2, y: 100, angle: 0, speed: 1.5 + level * 0.2 };
                for(let i = 0; i < this.segmentCount; i++) {
                    const isWeakPoint = i > 0 && i % 2 === 0;
                    const health = isWeakPoint ? 50 + level*10 : 9999;
                    this.segments.push({
                        x: canvas.width / 2, y: 100 + i * 20,
                        radius: (i === 0) ? 35 : 25, health: health, maxHealth: health, 
                        isHead: i === 0, isWeakPoint: isWeakPoint
                    });
                    if(isWeakPoint) this.totalHealth += health;
                }
                this.maxTotalHealth = this.totalHealth;
            }
            update(currentTime) {
                this.head.angle += 0.02;
                this.head.x = canvas.width / 2 + Math.sin(this.head.angle) * (canvas.width / 2 - 40);
                this.head.y = 120 + Math.cos(this.head.angle * 2) * 50;
                let leader = this.head;
                this.segments.forEach(seg => {
                    if (seg.health > 0) {
                        const dx = leader.x - seg.x, dy = leader.y - seg.y;
                        const dist = Math.hypot(dx, dy);
                        const followDist = seg.isHead ? 0 : seg.radius * 0.8;
                        if(dist > followDist) { seg.x += dx * 0.15; seg.y += dy * 0.15; }
                        leader = seg;
                    }
                });
                if (this.totalHealth <= 0) bossDefeated();
            }
            draw() {
                 this.segments.forEach((seg) => {
                     if (seg.health > 0) {
                        ctx.beginPath();
                        ctx.fillStyle = seg.isWeakPoint ? '#FFC107' : (seg.isHead ? '#795548' : '#A1887F'); 
                        ctx.strokeStyle = seg.isWeakPoint ? '#FF8F00' : '#4E342E';
                        ctx.lineWidth = 3; ctx.arc(seg.x, seg.y, seg.radius, 0, Math.PI * 2);
                        ctx.fill(); ctx.stroke();
                        if(seg.isHead){
                            ctx.fillStyle = '#FF5722'; ctx.beginPath();
                            ctx.arc(seg.x, seg.y, 10, 0, Math.PI*2); ctx.fill();
                        }
                     }
                 });
            }
            takeDamage(amount, segmentIndex) {
                const seg = this.segments[segmentIndex];
                if(seg && seg.health > 0 && seg.isWeakPoint) {
                    seg.health -= amount; this.totalHealth -= amount;
                    playSound(sounds.bossHit, 300 + segmentIndex * 20);
                    createBurstParticles(seg.x, seg.y, '#FFD54F', 15);
                    if(seg.health <= 0) {
                        createBurstParticles(seg.x, seg.y, '#FFFFFF', 30); playSound(sounds.explosion);
                    }
                }
            }
            updateBossHealthDisplay() {
                const percentage = Math.max(0, (this.totalHealth / this.maxTotalHealth) * 100);
                bossHealthBar.style.width = `${percentage}%`;
                bossHealthText.textContent = `å·¨é°»å¼±é»: ${Math.ceil(percentage)}%`;
            }
        }
        
        class Boss3_SmogSpecter {
            constructor() {
                this.name = "è™›å¯¦æ€¨éˆ"; this.specters = [];
                this.maxHealth = 120 + level * 25; this.health = this.maxHealth;
                this.timeLimit = 65000; this.startTime = Date.now();
                this.smogOverlayAlpha = 0; this.lastTeleportTime = 0; this.teleportInterval = 5000;
                this.lastSmogAttackTime = 0; this.smogAttackInterval = 8000; this.spawnSpecters();
            }
            spawnSpecters() {
                this.specters = []; const realIndex = Math.floor(Math.random() * 4);
                for(let i=0; i<4; i++){
                    this.specters.push({
                        x: (canvas.width / 5) * (i + 1), y: Math.random() * 100 + 100,
                        radius: 40, isReal: i === realIndex, alpha: 1, isHit: false
                    });
                }
            }
            update(currentTime) {
                if(currentTime - this.lastTeleportTime > this.teleportInterval) {
                    this.spawnSpecters(); this.lastTeleportTime = currentTime;
                    showTemporaryMessage("æ€¨éˆè½‰ç§»äº†ä½ç½®ï¼", 1500, '#CE93D8');
                }
                if(currentTime - this.lastSmogAttackTime > this.smogAttackInterval) {
                    this.smogOverlayAlpha = 0.95; this.lastSmogAttackTime = currentTime;
                    showTemporaryMessage("æ¿ƒéœ§éšœç›®ï¼æ»‘å‹•æ¸…é™¤ï¼", 2000, '#B0BEC5');
                }
                this.specters.forEach(s => { if(s.isHit) s.alpha -= 0.1; });
                this.specters = this.specters.filter(s => s.alpha > 0);
                if (this.health <= 0) bossDefeated();
            }
            draw() {
                 this.specters.forEach(s => {
                    ctx.save(); ctx.globalAlpha = s.alpha;
                    const flicker = s.isReal ? 1.0 : 0.4;
                    ctx.fillStyle = `rgba(142, 36, 170, ${flicker})`; ctx.strokeStyle = '#4A148C';
                    drawShape('fume', s.radius, ctx, false); ctx.restore();
                 });
                 if (this.smogOverlayAlpha > 0) {
                     ctx.fillStyle = `rgba(55, 71, 79, ${this.smogOverlayAlpha})`;
                     ctx.fillRect(0, 0, canvas.width, canvas.height);
                 }
            }
            takeDamage(amount, specterIndex) {
                 const s = this.specters[specterIndex]; if(!s) return;
                 s.isHit = true;
                 if (s.isReal) {
                     this.health -= amount; playSound(sounds.bossHit, 400);
                     createBurstParticles(s.x, s.y, '#E1BEE7', 20); this.lastTeleportTime = Date.now();
                 } else {
                     playSound(sounds.error, 300, 0.2); createBurstParticles(s.x, s.y, '#CFD8DC', 10);
                 }
            }
            updateBossHealthDisplay() {
                const percentage = Math.max(0, (this.health / this.maxHealth) * 100);
                bossHealthBar.style.width = `${percentage}%`;
                bossHealthText.textContent = `æ€¨éˆ: ${Math.ceil(percentage)}%`;
            }
        }
        
        // --- Core Game Logic ---

        function showTemporaryMessage(message, duration, color = 'white') {
            const msgElement = document.createElement('div');
            msgElement.textContent = message;
            Object.assign(msgElement.style, {
                position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)',
                fontSize: 'clamp(1.5rem, 5vw, 2.2rem)', fontWeight: 'bold', color: color,
                backgroundColor: 'rgba(0,0,0,0.75)', padding: '25px', borderRadius: '15px',
                zIndex: '200', textShadow: '2px 2px 5px black', boxShadow: '0 0 20px rgba(255,255,255,0.3)',
                textAlign: 'center', pointerEvents: 'none'
            });
            gameContainer.appendChild(msgElement);
            setTimeout(() => { if (gameContainer.contains(msgElement)) gameContainer.removeChild(msgElement); }, duration);
        }
        
        function initGame() {
            score = 0; lives = 3; energy = 0; level = 1;
            gameSpeedMultiplier = 1; currentSpawnInterval = baseSpawnInterval;
            gameObjects = []; particles = []; swipePath = [];
            isSwiping = false; bossActive = false; boss = null;
            isSlowMotionActive = false; isShieldActive = false; isScoreMultiplierActive = false;
            
            bossHealthContainer.style.display = 'none';
            bossTimerContainer.style.display = 'none';
            gameContainer.style.background = `linear-gradient(180deg, #56ab2f 0%, #a8e063 100%)`;
            gameContainer.style.filter = `none`;
            updateUI();
            resizeCanvas();
        }

        function gameLoop(currentTime) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'playing' || gameState === 'bossFight') {
                updateItemEffects(currentTime);
                const slowMoFactor = isSlowMotionActive ? 0.3 : 1;
                
                if (gameState === 'playing' && currentTime - lastSpawnTime > currentSpawnInterval / slowMoFactor) {
                    spawnGameObject(); lastSpawnTime = currentTime;
                }
                
                gameObjects.forEach(obj => { obj.update(); obj.draw(); });
                gameObjects = gameObjects.filter(obj => obj.y < canvas.height + 100 && obj.x > -100 && obj.x < canvas.width + 100 && obj.alpha > 0);

                if (bossActive && boss) {
                    boss.update(currentTime);
                    if (boss) {
                        boss.draw();
                        boss.updateBossHealthDisplay();

                        const elapsedTime = Date.now() - boss.startTime;
                        const remainingTime = Math.max(0, boss.timeLimit - elapsedTime);
                        const timerPercentage = (remainingTime / boss.timeLimit) * 100;
                        bossTimerBar.style.width = `${timerPercentage}%`;
                        bossTimerText.textContent = `æ™‚é–“: ${Math.ceil(remainingTime / 1000)}s`;
                        if(remainingTime <= 0) {
                            handleBossTimeout();
                        }
                    }
                }

                particles.forEach(p => { p.update(); p.draw(); });
                particles = particles.filter(p => p.life > 0);
                if (isSwiping) drawSwipeTrail();
                
                updateUI();
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function handleBossTimeout() {
            bossActive = false;
            boss = null;
            
            lives--;
            updateUI();
            
            playSound(sounds.error, 200, 0.5);
            showTemporaryMessage("æ™‚é–“åˆ°ï¼é­”ç‹é€ƒè·‘äº†ï¼", 2500, '#FFB74D');
            
            if(lives <= 0) {
                triggerGameOver();
                return;
            }

            gameState = 'playing';
            bossHealthContainer.style.display = 'none';
            bossTimerContainer.style.display = 'none';
            gameContainer.style.background = `linear-gradient(180deg, #56ab2f 0%, #a8e063 100%)`;
            gameContainer.style.filter = 'none';
        }

        function triggerBossFight() {
            gameState = 'bossFight';
            bossActive = true;
            gameObjects = [];
            
            switch(level) {
                case 1: boss = new Boss1_PollutionCore(); break;
                case 2: boss = new Boss2_WasteWyrm(); break;
                case 3: boss = new Boss3_SmogSpecter(); break;
            }

            gameContainer.style.background = level === 1 ? `linear-gradient(180deg, #420D09 0%, #6A1B1B 100%)` :
                                            level === 2 ? `linear-gradient(180deg, #3E2723 0%, #5D4037 100%)` :
                                                          `linear-gradient(180deg, #311B92 0%, #4527A0 100%)`;
            
            showTemporaryMessage(`é—œå¡ ${level} é­”ç‹ä¾†è¥²ï¼š${boss.name}ï¼`, 3000, '#F06292');
            gameContainer.style.filter = `brightness(0.9)`;
            bossHealthContainer.style.display = 'block';
            bossTimerContainer.style.display = 'block';
            energy = 0;
            updateUI();
        }

        function bossDefeated() {
            createBurstParticles(canvas.width / 2, canvas.height / 2, '#00E676', 200, 15);
            addScore(500 * level);
            level++;
            
            bossHealthContainer.style.display = 'none';
            bossTimerContainer.style.display = 'none';
            bossActive = false;
            boss = null;

            if (level > 3) {
                 triggerWin();
                 return;
            }
            
            gameState = 'playing';
            gameContainer.style.background = `linear-gradient(180deg, #56ab2f 0%, #a8e063 100%)`;
            gameContainer.style.filter = 'none';
            showTemporaryMessage(`é­”ç‹å·²æ·¨åŒ–ï¼æº–å‚™æŒ‘æˆ°ä¸‹ä¸€é—œï¼`, 3000, '#00E676');
        }
        
        function lineCircleIntersection(p1, p2, circle) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const lenSq = dx * dx + dy * dy;
            if (lenSq === 0) {
                const distSq = Math.pow(circle.x - p1.x, 2) + Math.pow(circle.y - p1.y, 2);
                return distSq < circle.radius * circle.radius;
            }
            const t = ((circle.x - p1.x) * dx + (circle.y - p1.y) * dy) / lenSq;
            const tClamped = Math.max(0, Math.min(1, t));
            const closestX = p1.x + tClamped * dx;
            const closestY = p1.y + tClamped * dy;
            const distSq = Math.pow(circle.x - closestX, 2) + Math.pow(circle.y - closestY, 2);
            return distSq < circle.radius * circle.radius;
        }

        function handleSwipeInteraction(x, y) {
            if (bossActive && boss instanceof Boss3_SmogSpecter && boss.smogOverlayAlpha > 0) {
                boss.smogOverlayAlpha -= 0.05;
                createBurstParticles(x, y, `rgba(200,200,200,0.5)`, 5, 3);
                return;
            }

            const p2 = { x, y };
            const p1 = swipePath.length > 1 ? swipePath[swipePath.length - 2] : p2;

            if (bossActive && boss) {
                 if (boss instanceof Boss1_PollutionCore) {
                    const angle = Math.atan2(y - boss.y, x - boss.x);
                    let isBlocked = false;
                    for (let i = 0; i < boss.shieldArms; i++) {
                        const armAngle = (i / boss.shieldArms) * Math.PI * 2 + boss.shieldRotation;
                        const angleDiff = Math.abs(angle - armAngle) % (Math.PI * 2);
                        const armWidthAngle = Math.atan2(boss.shieldArmWidth / 2, boss.radius);
                        if(Math.min(angleDiff, Math.PI * 2 - angleDiff) < armWidthAngle) {
                            isBlocked = true;
                            break;
                        }
                    }
                    if (!isBlocked && Math.hypot(x-boss.x, y-boss.y) < boss.radius) {
                        boss.takeDamage(15);
                    }
                } else if (boss instanceof Boss2_WasteWyrm) {
                    for(let i = 0; i < boss.segments.length; i++) {
                        const seg = boss.segments[i];
                        if(seg.health > 0 && lineCircleIntersection(p1, p2, seg)) {
                            boss.takeDamage(20, i);
                            break; 
                        }
                    }
                } else if (boss instanceof Boss3_SmogSpecter) {
                    for(let i = 0; i < boss.specters.length; i++) {
                        const s = boss.specters[i];
                        if(!s.isHit && lineCircleIntersection(p1, p2, s)) {
                            boss.takeDamage(30, i);
                            break;
                        }
                    }
                }
            }

            for (let i = gameObjects.length - 1; i >= 0; i--) {
                const obj = gameObjects[i];
                if (obj.isHit) continue;
                if (lineCircleIntersection(p1, p2, obj)) {
                    obj.isHit = true;
                    if (POLLUTANT_TYPES.includes(obj.type)) {
                        addScore(10); addEnergy(5); playSound(sounds.clean, 400 + Math.random() * 200);
                        createBurstParticles(obj.x, obj.y, '#76FF03', 15, 8);
                    } else if (ITEM_TYPES.includes(obj.type)) {
                        activateItemEffect(obj.type, {x, y});
                    } else if (PROTECTED_TYPES.includes(obj.type)) {
                        handleMistake(obj.x, obj.y);
                    }
                    return;
                }
            }
        }
        
        function activateSpecialAttack() {
            if (!bossActive || energy < maxEnergy) return;
            
            energy = 0;
            playSound(sounds.powerUp, 600, 0.6);
            showTemporaryMessage("æ·¨åŒ–è¡æ“Šï¼", 1500, '#FFF59D');

            if (boss instanceof Boss1_PollutionCore) { boss.takeDamage(50); }
            else if (boss instanceof Boss2_WasteWyrm) {
                 for(let i = 0; i < boss.segments.length; i++) {
                     if(boss.segments[i].isWeakPoint) boss.takeDamage(75, i);
                 }
            } 
            else if (boss instanceof Boss3_SmogSpecter) {
                const realSpecterIndex = boss.specters.findIndex(s => s.isReal);
                if (realSpecterIndex !== -1) {
                    boss.takeDamage(80, realSpecterIndex);
                }
            }
            updateUI();
        }
        
        const styleSheet = document.createElement("style");
        styleSheet.innerText = `@keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 50%, 90% { transform: translateX(-6px); } 30%, 70% { transform: translateX(6px); } } .animate-shake { animation: shake 0.35s cubic-bezier(.36,.07,.19,.97) both; }`;
        document.head.appendChild(styleSheet);
        
        function handleMistake(x, y) {
             if (isShieldActive) {
                isShieldActive = false; playSound(sounds.itemCollect, 300, 0.3); createBurstParticles(x, y, '#4DB6AC', 20, 8);
            } else {
                lives--; playSound(sounds.error, 150, 0.2); createBurstParticles(x, y, '#EF5350', 20, 8);
                gameContainer.classList.add('animate-shake'); setTimeout(() => gameContainer.classList.remove('animate-shake'), 300);
                if (lives <= 0) triggerGameOver();
            }
        }
        
        function playSound(soundNode, freqOrNull, duration = 0.1) {
            if (Tone.context.state !== 'running') Tone.start().catch(e => console.warn("Tone.start() failed:", e));
            try {
                if(soundNode.state === "started") return;
                if (soundNode.name === "NoiseSynth" || soundNode.name === "MembraneSynth") soundNode.triggerAttackRelease(duration);
                else if (freqOrNull !== null) soundNode.triggerAttackRelease(freqOrNull, duration);
            } catch (e) { /* console.warn("Error playing sound:", e); */ }
        }
        
        function spawnGameObject() {
            let numToSpawn = Math.min(4, 1 + Math.floor(score / 500));
            for (let k = 0; k < numToSpawn; k++) {
                let type;
                if (Math.random() < ITEM_SPAWN_CHANCE) { type = ITEM_TYPES.filter(t => t !== GameObjectType.BOSS1_CELL)[Math.floor(Math.random() * (ITEM_TYPES.length -1))]; } 
                else { type = Math.random() < 0.6 ? POLLUTANT_TYPES.filter(t=> t !== GameObjectType.BOSS1_MINION)[Math.floor(Math.random() * (POLLUTANT_TYPES.length - 1))] : PROTECTED_TYPES[Math.floor(Math.random() * PROTECTED_TYPES.length)]; }
                
                const x = Math.random() * canvas.width;
                const y = -60;

                const newObj = new GameObject(x, y, type);
                
                const speedFactor = 0.15 + (energy / maxEnergy) * 1.0;
                const baseSpeed = (newObj.isItem ? 1.0 : 1.5) * gameSpeedMultiplier * speedFactor;
                
                newObj.vy = (Math.random() * 0.4 + 0.6) * baseSpeed;
                newObj.vx = (Math.random() - 0.5) * baseSpeed;
                
                gameObjects.push(newObj);
            }
        }

        function addScore(points) { score += points * (isScoreMultiplierActive ? 2 : 1); gameSpeedMultiplier = Math.min(2.5, 1 + score / 1000); currentSpawnInterval = Math.max(300, baseSpawnInterval - (score / 20)); }
        
        function addEnergy(amount) {
            if (energy >= maxEnergy && bossActive) return; 
            const oldEnergy = energy;
            energy = Math.min(energy + amount, maxEnergy);
            
            if (oldEnergy < maxEnergy && energy >= maxEnergy) {
                 playSound(sounds.powerUp, 400);
                 if (!bossActive && gameState === 'playing') {
                    triggerBossFight();
                 } else if(bossActive) {
                    activateSpecialAttack();
                 }
            }
            updateUI();
        }
        
        function updateUI() {
            scoreDisplay.textContent = `åˆ†æ•¸: ${score}`; livesDisplay.textContent = `ç”Ÿå‘½: ${lives}`;
            const energyPercentage = (energy / maxEnergy) * 100;
            energyBar.style.width = `${energyPercentage}%`;
            energyText.textContent = energyPercentage >= 15 ? `èƒ½é‡: ${Math.floor(energyPercentage)}%` : '';
            energyBar.classList.toggle('full', energyPercentage >= 100);
            shieldStatus.style.display = isShieldActive ? 'flex' : 'none';
            multiplierStatus.style.display = isScoreMultiplierActive ? 'flex' : 'none';
        }
        
        function updateItemEffects(currentTime) {
            if (isSlowMotionActive && currentTime > slowMotionEndTime) isSlowMotionActive = false;
            if (isScoreMultiplierActive && currentTime > scoreMultiplierEndTime) isScoreMultiplierActive = false;
        }

        function activateItemEffect(itemType, position) {
            const currentTime = Date.now();
            playSound(sounds.itemCollect, 600); createBurstParticles(position.x, position.y, '#FFD700', 25, 10);
            switch (itemType) {
                case GameObjectType.ITEM_SLOW_MOTION: isSlowMotionActive = true; slowMotionEndTime = currentTime + SLOW_MOTION_DURATION; showTemporaryMessage("æ™‚é–“ç·©ç·©ï¼", 2000, '#B0BEC5'); break;
                case GameObjectType.ITEM_SHIELD: isShieldActive = true; showTemporaryMessage("å®ˆè­·å…‰ç›¾ï¼", 2000, '#4DB6AC'); break;
                case GameObjectType.ITEM_SCORE_MULTIPLIER: isScoreMultiplierActive = true; scoreMultiplierEndTime = currentTime + ITEM_EFFECT_DURATION; showTemporaryMessage("é›™å€ç©åˆ†ï¼", 2000, '#FFD54F'); break;
                case GameObjectType.ITEM_ENERGY_BOOST: addEnergy(40); showTemporaryMessage("èƒ½é‡è£œå……ï¼", 1500, '#FFEE58'); break;
            }
            updateUI();
        }

        class Particle {
            constructor(x, y, color, size, life) { this.x = x; this.y = y; this.size = Math.random() * size + 2; this.color = color; this.life = life || Math.random() * 60 + 40; this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; this.alpha = 1; this.gravity = 0.05; }
            update() { const slowMoEffect = isSlowMotionActive ? 0.3 : 1; this.vy += this.gravity * slowMoEffect; this.x += this.vx * slowMoEffect; this.y += this.vy * slowMoEffect; this.life--; this.alpha = this.life / 60; }
            draw() { ctx.globalAlpha = Math.max(0, this.alpha); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
        }
        function createBurstParticles(x, y, color, count, size = 5, life = 50) { for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color, size, life)); }
        
        function drawSwipeTrail() {
            if (swipePath.length < 2) return;
            ctx.strokeStyle = `rgba(173, 216, 230, 0.7)`;
            ctx.lineWidth = 12; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.shadowColor = `rgba(173, 216, 230, 0.7)`; ctx.shadowBlur = 15; ctx.beginPath();
            ctx.moveTo(swipePath[0].x, swipePath[0].y);
            for (let i = 1; i < swipePath.length; i++) { ctx.lineTo(swipePath[i].x, swipePath[i].y); }
            ctx.stroke(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
        }
        
        function switchScreen(activeScreen) { [startScreen, gameOverScreen, pauseScreen, howToPlayScreen, winScreen].forEach(s => s.classList.remove('active')); if (activeScreen) activeScreen.classList.add('active'); }
        function startGameFlow() { initGame(); gameState = 'playing'; switchScreen(null); if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(gameLoop); }
        function triggerGameOver() { gameState = 'gameOver'; finalScoreDisplay.textContent = `ä½ çš„æœ€çµ‚åˆ†æ•¸: ${score}`; switchScreen(gameOverScreen); playSound(sounds.error, 80, 0.6); if (bossActive) { bossHealthContainer.style.display = 'none'; bossTimerContainer.style.display = 'none'; } }
        function triggerWin() { gameState = 'win'; winFinalScoreDisplay.textContent = `ä½ çš„æœ€çµ‚åˆ†æ•¸: ${score}`; switchScreen(winScreen); playSound(sounds.powerUp, 1000, 1.5); if (bossActive) { bossHealthContainer.style.display = 'none'; bossTimerContainer.style.display = 'none'; } }
        function pauseGame() { if (gameState === 'playing' || gameState === 'bossFight') { gameState = 'paused'; switchScreen(pauseScreen); cancelAnimationFrame(animationFrameId); } }
        function resumeGame() { if (gameState === 'paused') { gameState = bossActive ? 'bossFight' : 'playing'; switchScreen(null); animationFrameId = requestAnimationFrame(gameLoop); } }
        
        function handleMouseDown(e) { if (gameState !== 'playing' && gameState !== 'bossFight') return; isSwiping = true; const rect = canvas.getBoundingClientRect(); swipePath = [{ x: e.clientX - rect.left, y: e.clientY - rect.top }]; playSound(sounds.swipe, 300, 0.05); }
        function handleMouseMove(e) { if (!isSwiping) return; const rect = canvas.getBoundingClientRect(); const newPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top }; swipePath.push(newPoint); if(swipePath.length > 20) swipePath.shift(); handleSwipeInteraction(newPoint.x, newPoint.y); }
        function handleMouseUp(e) { isSwiping = false; }
        function handleTouchStart(e) { if (gameState !== 'playing' && gameState !== 'bossFight') return; e.preventDefault(); const touch = e.touches[0]; const rect = canvas.getBoundingClientRect(); isSwiping = true; swipePath = [{ x: touch.clientX - rect.left, y: touch.clientY - rect.top }]; playSound(sounds.swipe, 300, 0.05); }
        function handleTouchMove(e) { if (!isSwiping) return; e.preventDefault(); const touch = e.touches[0]; const rect = canvas.getBoundingClientRect(); const newPoint = { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; swipePath.push(newPoint); if(swipePath.length > 20) swipePath.shift(); handleSwipeInteraction(newPoint.x, newPoint.y); }
        function handleTouchEnd(e) { isSwiping = false; }
        
        gameContainer.addEventListener('contextmenu', e => e.preventDefault());
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', () => isSwiping = false);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        
        document.querySelectorAll('.action-button').forEach(button => button.addEventListener('click', () => playSound(sounds.buttonClick, 500)));
        startButton.addEventListener('click', startGameFlow);
        restartButton.addEventListener('click', startGameFlow);
        playAgainButton.addEventListener('click', startGameFlow);
        pauseButton.addEventListener('click', pauseGame);
        resumeButton.addEventListener('click', resumeGame);
        quitButton.addEventListener('click', () => { switchScreen(startScreen); initGame(); gameState = 'start'; if (animationFrameId) cancelAnimationFrame(animationFrameId); });
        howToPlayButton.addEventListener('click', () => switchScreen(howToPlayScreen));
        closeHowToPlayButton.addEventListener('click', () => switchScreen(startScreen));
        
        function drawShape(type, radius, c, isIcon) {
            c.beginPath(); const lineWidth = isIcon ? 1.5 : 2.5; const bossCoreLineWidth = isIcon ? 2 : 4;
            switch (type) {
                case GameObjectType.POLLUTANT_PLASTIC: case 'plastic_icon':
                    c.fillStyle = '#89B0AE'; c.strokeStyle = '#5F7A7A'; c.lineWidth = lineWidth;
                    c.moveTo(-radius * 0.5, radius * 0.9); c.lineTo(-radius * 0.6, -radius * 0.4); c.quadraticCurveTo(-radius * 0.6, -radius * 0.6, -radius * 0.4, -radius * 0.7);
                    c.lineTo(radius * 0.4, -radius * 0.7); c.quadraticCurveTo(radius * 0.6, -radius * 0.6, radius * 0.6, -radius * 0.4); c.lineTo(radius * 0.5, radius * 0.9);
                    c.closePath(); c.fill(); c.stroke(); c.fillStyle = '#5F7A7A'; c.fillRect(-radius * 0.4, -radius, radius*0.8, radius * 0.3); break;
                case GameObjectType.POLLUTANT_FUME: case 'fume_icon':
                    c.fillStyle = '#6B7280'; c.strokeStyle = '#4B5563'; c.lineWidth = isIcon ? 1 : 2;
                    c.arc(0, 0, radius * 0.7, 0, Math.PI * 2); c.arc(radius * 0.5, radius * 0.3, radius * 0.5, 0, Math.PI * 2);
                    c.arc(-radius * 0.4, radius * 0.2, radius * 0.6, 0, Math.PI * 2); c.arc(0, -radius * 0.4, radius * 0.5, 0, Math.PI * 2); c.fill(); break;
                case GameObjectType.POLLUTANT_OIL: case 'oil_icon':
                    c.fillStyle = '#3A3A3A'; c.strokeStyle = '#1A1A1A'; c.lineWidth = lineWidth;
                    c.moveTo(0, -radius * 0.5); c.bezierCurveTo(radius, -radius, radius, radius, 0, radius); c.bezierCurveTo(-radius, radius, -radius, -radius * 0.8, 0, -radius * 0.5);
                    c.fill(); c.stroke(); c.fillStyle = 'rgba(255, 255, 255, 0.4)'; c.beginPath(); c.arc(-radius * 0.3, -radius * 0.2, radius * 0.25, 0, Math.PI * 2); c.fill(); break;
                case GameObjectType.PROTECTED_SAPLING: case 'sapling_icon':
                    c.fillStyle = '#8D6E63'; c.strokeStyle = '#5D4037'; c.lineWidth = lineWidth; c.beginPath(); c.rect(-radius * 0.15, 0, radius * 0.3, radius); c.fill(); c.stroke();
                    c.fillStyle = '#66BB6A'; c.strokeStyle = '#388E3C'; c.beginPath(); c.arc(0, -radius * 0.3, radius * 0.7, Math.PI, Math.PI * 2); c.closePath(); c.fill(); c.stroke(); break;
                case GameObjectType.PROTECTED_WATER: case 'water_icon':
                    c.fillStyle = '#4FC3F7'; c.strokeStyle = '#03A9F4'; c.lineWidth = lineWidth;
                    c.moveTo(0, -radius); c.bezierCurveTo(radius * 1.3, -radius * 0.8, radius * 0.8, radius, 0, radius); c.bezierCurveTo(-radius * 0.8, radius, -radius * 1.3, -radius * 0.8, 0, -radius);
                    c.fill(); c.stroke(); break;
                case 'boss_core':
                    c.fillStyle = `rgba(255, 0, 0, ${0.7 + Math.sin(Date.now()/120)*0.3})`; c.strokeStyle = '#B71C1C'; c.lineWidth = bossCoreLineWidth; c.arc(0, 0, radius, 0, Math.PI * 2); c.fill(); c.stroke(); break;
                case GameObjectType.ITEM_SLOW_MOTION: case 'slowmo_icon':
                    c.fillStyle = '#B0BEC5'; c.strokeStyle = '#78909C'; c.lineWidth = isIcon ? 1.5 : 2; c.arc(0, 0, radius, 0, Math.PI * 2); c.fill(); c.stroke();
                    c.beginPath(); c.fillStyle = '#546E7A'; c.moveTo(0,0); c.lineTo(0, -radius * 0.7); c.moveTo(0,0); c.lineTo(radius * 0.5, 0); c.stroke(); break;
                case GameObjectType.ITEM_SHIELD: case 'shield_icon':
                    c.fillStyle = '#4DB6AC'; c.strokeStyle = '#00897B'; c.lineWidth = isIcon ? 1.5 : 2;
                    c.moveTo(0, -radius); c.quadraticCurveTo(radius, -radius * 0.5, radius, 0); c.quadraticCurveTo(radius, radius * 0.8, 0, radius);
                    c.quadraticCurveTo(-radius, radius * 0.8, -radius, 0); c.quadraticCurveTo(-radius, -radius * 0.5, 0, -radius); c.fill(); c.stroke(); break;
                case GameObjectType.ITEM_SCORE_MULTIPLIER: case 'multi_icon':
                    c.fillStyle = '#FFD54F'; c.strokeStyle = '#FFB300'; c.lineWidth = isIcon ? 1.5 : 2; c.beginPath();
                    for (let i = 0; i < 5; i++) { c.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * radius, -Math.sin((18 + i * 72) / 180 * Math.PI) * radius); c.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * radius * 0.5, -Math.sin((54 + i * 72) / 180 * Math.PI) * radius * 0.5); }
                    c.closePath(); c.fill(); c.stroke();
                    if(!isIcon) { c.fillStyle = '#BF360C'; c.font = `bold ${radius*0.7}px Arial`; c.textAlign = 'center'; c.textBaseline = 'middle'; c.fillText('x2', 0, radius*0.1); } break;
                case GameObjectType.ITEM_ENERGY_BOOST: case 'energy_icon':
                    c.fillStyle = '#FFEE58'; c.strokeStyle = '#FDD835'; c.lineWidth = isIcon ? 1.5 : 2;
                    c.moveTo(-radius * 0.2, -radius); c.lineTo(radius * 0.3, -radius * 0.1); c.lineTo(0, -radius * 0.1);
                    c.lineTo(radius * 0.2, radius); c.lineTo(-radius * 0.3, -radius * 0.2); c.lineTo(0, -radius * 0.2); c.closePath(); c.fill(); c.stroke(); break;
                case GameObjectType.BOSS1_MINION:
                     c.fillStyle = '#AB47BC'; c.strokeStyle = '#6A1B9A'; c.lineWidth = lineWidth;
                     for (let i = 0; i < 6; i++) { c.lineTo(Math.cos(i / 3 * Math.PI) * radius, Math.sin(i / 3 * Math.PI) * radius * 0.5); }
                     c.closePath(); c.fill(); c.stroke(); break;
                case GameObjectType.BOSS1_CELL:
                     c.fillStyle = '#FFF176'; c.strokeStyle = '#FDD835'; c.lineWidth = lineWidth;
                     c.rect(-radius*0.5, -radius*0.5, radius, radius); c.fill(); c.stroke(); break;
                default: c.fillStyle = 'magenta'; c.arc(0,0,radius,0,Math.PI*2); c.fill(); break;
            }
        }

        document.querySelectorAll('.item-icon-canvas').forEach(iconCanvas => {
            const iconCtx = iconCanvas.getContext('2d');
            iconCtx.width = 22; iconCtx.height = 22;
            iconCtx.clearRect(0,0,22,22); iconCtx.save();
            iconCtx.translate(11, 11);
            drawShape(iconCanvas.dataset.type, 9, iconCtx, true);
            iconCtx.restore();
        });

        // --- Initial Load ---
        switchScreen(startScreen);
        resizeCanvas();
        
    </script>
</body>
</html>
