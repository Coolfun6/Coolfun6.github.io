<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>戰鬥雞：無盡征途 (地獄+)</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #1a2533; /* 更深的藍灰 */
            font-family: 'Courier New', Courier, monospace;
            color: white;
            overflow: hidden; /* 避免頁面滾動條 */
        }
        canvas {
            border: 2px solid #fff;
            background-color: #87CEEB;
            image-rendering: pixelated; /* 保持像素風格 */
            position: relative;
        }
        #gameContainer {
            position: relative;
        }
        #damageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.5);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s ease-in-out;
        }
        #gameUI {
            margin-top: 10px;
            font-size: 18px;
            display: flex;
            justify-content: space-around;
            width: 800px;
            flex-wrap: wrap;
        }
        #gameUI span {
            margin: 2px 10px;
        }
        #controlsInfo {
            margin-top: 10px;
            font-size: 14px;
            text-align: center;
        }
        .button {
            padding: 10px 20px;
            font-size: 18px;
            color: white;
            background-color: #27ae60;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        .button:hover {
            background-color: #229954;
        }
    </style>
</head>
<body>
    <h1>戰鬥雞：無盡征途 (地獄+)</h1>
    <div id="gameUI">
        <span id="score">分數: 0</span>
        <span id="stage">大關卡: 1</span>
        <span id="progress">進度: 0m</span>
        <span id="health">生命: 100</span>
        <span id="weapon">武器: 小雞啄米槍</span>
        <span id="skillStatus">技能: 就緒! (S)</span>
    </div>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="damageOverlay"></div>
    </div>
    <div id="controlsInfo">
        ← →/A D: 移動 | ↑/W: 跳躍 (可二段跳) | 空白鍵: 射擊 | S: 技能 | Q/E: 切換武器
    </div>
    <button id="startButton" class="button">開始遊戲</button>
    <div id="messageDisplay" style="font-size: 22px; margin-top: 8px; color: #e67e22;"></div>

    <script>
        // --- 基本設定 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const damageOverlay = document.getElementById('damageOverlay');
        const scoreDisplay = document.getElementById('score');
        const stageDisplay = document.getElementById('stage');
        const progressDisplay = document.getElementById('progress');
        const healthDisplay = document.getElementById('health');
        const weaponDisplay = document.getElementById('weapon');
        const skillStatusDisplay = document.getElementById('skillStatus');
        const startButton = document.getElementById('startButton');
        const messageDisplay = document.getElementById('messageDisplay');

        // --- 遊戲狀態 ---
        let score = 0;
        let currentMajorStage = 1;
        const MAX_STAGES = 5;
        let playerHealth = 100;
        let gameRunning = false;
        let gameOver = false;
        let gameWon = false;
        let cameraX = 0;
        let worldGeneratedUpToX = 0;
        let gameTime = 0;
        const TIME_SCALE = 0.1;
        let stars = [];
        let clouds = [];
        let muzzleFlashes = [];
        let environmentalHazards = [];

        // --- 物理與玩家常數 ---
        const GRAVITY = 0.6;
        const JUMP_FORCE = -12;
        const PLAYER_WIDTH = 40;
        const PLAYER_HEIGHT = 40;
        const PLAYER_SPEED = 4;
        const ENEMY_BULLET_MAX_RANGE = canvas.width * 0.7;

        // --- Web Audio API 音效設定 ---
        let audioCtx;
        let masterGainNode;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx) {
                masterGainNode = audioCtx.createGain();
                masterGainNode.gain.setValueAtTime(0.25, audioCtx.currentTime);
                masterGainNode.connect(audioCtx.destination);
            }
        } catch (e) {
            console.warn("Web Audio API is not supported in this browser.");
            audioCtx = null;
        }
        
        // --- 音效函式 ---
        function playSound(type, options = {}) {
            if (!audioCtx || !masterGainNode) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(masterGainNode);
            let freq1 = 220, freq2 = 440, duration = 0.1, vol = 0.5;
            oscillator.type = 'triangle';
            switch (type) {
                case 'player_shoot':
                    oscillator.type = 'square';
                    const currentWeaponKeyShoot = player.weapons[player.currentWeaponIndex];
                    freq1 = WEAPON_TYPES[currentWeaponKeyShoot].name === '爆蛋發射器' ? 280 : WEAPON_TYPES[currentWeaponKeyShoot].name === '羽毛散射砲' ? 520 : 440;
                    duration = 0.08; vol = 0.15;
                    oscillator.frequency.setValueAtTime(freq1, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
                    break;
                case 'enemy_die':
                    oscillator.type = 'sawtooth';
                    freq1 = 150; freq2 = 50; duration = 0.15; vol = 0.1;
                    oscillator.frequency.setValueAtTime(freq1, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(freq2, audioCtx.currentTime + duration);
                    gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
                    break;
                case 'player_jump':
                    oscillator.type = 'sine';
                    freq1 = options.isDoubleJump ? 392 : 261;
                    freq2 = options.isDoubleJump ? 587 : 523;
                    duration = 0.12; vol = 0.2;
                    oscillator.frequency.setValueAtTime(freq1, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(freq2, audioCtx.currentTime + duration * 0.8);
                    gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
                    break;
                case 'pickup_weapon':
                    oscillator.type = 'sine';
                    freq1 = 523; freq2 = 783; duration = 0.3; vol = 0.25;
                    oscillator.frequency.setValueAtTime(freq1, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
                    const osc2_w = audioCtx.createOscillator(); const gain2_w = audioCtx.createGain();
                    osc2_w.connect(gain2_w); gain2_w.connect(masterGainNode); osc2_w.type = 'sine';
                    osc2_w.frequency.setValueAtTime(freq2, audioCtx.currentTime + 0.05);
                    gain2_w.gain.setValueAtTime(vol * 0.8, audioCtx.currentTime + 0.05);
                    gain2_w.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration + 0.05);
                    osc2_w.start(audioCtx.currentTime + 0.05); osc2_w.stop(audioCtx.currentTime + duration + 0.05);
                    break;
                case 'pickup_health':
                     oscillator.type = 'triangle';
                     freq1 = 440; freq2 = 660; duration = 0.2; vol = 0.2;
                     oscillator.frequency.setValueAtTime(freq1, audioCtx.currentTime);
                     oscillator.frequency.exponentialRampToValueAtTime(freq2, audioCtx.currentTime + duration * 0.7);
                     gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                     gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
                     break;
                case 'skill_use':
                    oscillator.type = 'noise'; duration = 0.5; vol = 0.3;
                    const bqFilter = audioCtx.createBiquadFilter();
                    bqFilter.type = "bandpass"; bqFilter.frequency.setValueAtTime(800, audioCtx.currentTime);
                    bqFilter.Q.setValueAtTime(5, audioCtx.currentTime); oscillator.connect(bqFilter);
                    bqFilter.connect(gainNode); gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
                    break;
                case 'player_hit':
                    oscillator.type = 'triangle';
                    freq1 = 200; freq2 = 100; duration = 0.2; vol = options.volume !== undefined ? options.volume : 0.3;
                    oscillator.frequency.setValueAtTime(freq1, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(freq2, audioCtx.currentTime + duration);
                    gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
                    break;
                case 'boss_hit':
                    oscillator.type = 'square';
                    freq1 = 100; duration = 0.1; vol = 0.2;
                    oscillator.frequency.setValueAtTime(freq1, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
                    break;
                case 'boss_die':
                    oscillator.type = 'sawtooth';
                    freq1 = 250; freq2 = 30; duration = 1.0; vol = 0.4;
                    oscillator.frequency.setValueAtTime(freq1, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(freq2, audioCtx.currentTime + duration);
                    gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
                    const noiseOsc = audioCtx.createOscillator(); noiseOsc.type = 'noise';
                    const noiseGain = audioCtx.createGain(); noiseOsc.connect(noiseGain); noiseGain.connect(masterGainNode);
                    noiseGain.gain.setValueAtTime(vol * 0.5, audioCtx.currentTime);
                    noiseGain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration * 0.8);
                    noiseOsc.start(audioCtx.currentTime); noiseOsc.stop(audioCtx.currentTime + duration * 0.8);
                    break;
            }
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration + 0.01);
        }

        // --- 武器系統 ---
        const WEAPON_TYPES = {
            'peck_cannon': { name: '小雞啄米槍', fireRate: 300, bulletSpeed: 8, bulletRadius: 5, bulletColor: '#FFFF00', damage: 10, pattern: 'single', ammo: Infinity },
            'feather_spread': { name: '羽毛散射砲', fireRate: 600, bulletSpeed: 7, bulletRadius: 4, bulletColor: '#ADD8E6', damage: 7, pattern: 'triple_spread', ammo: 50, maxAmmo: 50 },
            'egg_launcher': { name: '爆蛋發射器', fireRate: 1000, bulletSpeed: 6, bulletRadius: 8, bulletColor: '#FFA07A', damage: 25, pattern: 'single_big', ammo: 20, maxAmmo: 20 }
        };

        // --- 技能與魔王相關 ---
        const SKILL_COOLDOWN = 12000;
        let skillReady = true; let lastSkillTime = 0;
        const BOSS_SPAWN_INTERVAL = 2500;
        let bossActive = false; let activeBoss = null;
        let nextBossSpawnX = BOSS_SPAWN_INTERVAL;
        
        // --- 魔王皮膚設定 ---
        const BOSS_TYPES = [
            { name: '高麗菜國王', type: 'boss_cabbage_king', health: 350, width: 70, height: 70, color: '#5DBB63', damage: 15, specialCooldown: 8000 },
            { name: '番茄領主', type: 'boss_tomato_lord', health: 500, width: 80, height: 80, color: '#D44A4A', damage: 20, specialCooldown: 9000 },
            { name: '玉米將軍', type: 'boss_corn_general', health: 750, width: 60, height: 100, color: '#F8D568', damage: 25, specialCooldown: 7000 },
            { name: '洋蔥霸主', type: 'boss_onion_overlord', health: 1000, width: 90, height: 90, color: '#B264C3', damage: 30, specialCooldown: 10000 },
            { name: '南瓜大帝', type: 'boss_pumpkin_emperor', health: 1500, width: 100, height: 100, color: '#F37021', damage: 35, specialCooldown: 8000 }
        ];

        // --- 玩家物件 ---
        const player = {
            worldX: 100, worldY: canvas.height - PLAYER_HEIGHT - 100,
            width: PLAYER_WIDTH, height: PLAYER_HEIGHT,
            dx: 0, dy: 0, grounded: false, facingRight: true,
            color: '#FFD700', bullets: [],
            weapons: ['peck_cannon'],
            currentWeaponIndex: 0,
            lastShotTime: 0,
            P_feather_spread_ammo: 0,
            P_egg_launcher_ammo: 0,
            invincible: false,
            invincibleTimer: 0,
            jumps: 2,
            maxJumps: 2,

            shoot: function() {
                const now = Date.now();
                const currentWeaponKey = this.weapons[this.currentWeaponIndex];
                const weaponStats = WEAPON_TYPES[currentWeaponKey];

                if (now - this.lastShotTime < weaponStats.fireRate) return;

                let currentAmmoForWeapon = Infinity;
                if (currentWeaponKey === 'feather_spread') currentAmmoForWeapon = this.P_feather_spread_ammo;
                else if (currentWeaponKey === 'egg_launcher') currentAmmoForWeapon = this.P_egg_launcher_ammo;

                if (weaponStats.ammo !== Infinity && currentAmmoForWeapon <= 0) {
                    messageDisplay.textContent = `${weaponStats.name} 沒子彈了!`;
                    setTimeout(()=> messageDisplay.textContent = "", 1500);
                    playSound('player_shoot', {freq1: 100, duration: 0.2});
                    return;
                }

                this.lastShotTime = now;
                playSound('player_shoot');
                const bulletY = this.worldY + this.height / 2 - weaponStats.bulletRadius;
                
                const muzzleXOffset = this.facingRight ? this.width + 10 : -10;
                const muzzleYOffset = this.height * 0.55;
                muzzleFlashes.push({
                    x: this.worldX + muzzleXOffset,
                    y: this.worldY + muzzleYOffset,
                    alpha: 1
                });

                const bulletXOffset = this.facingRight ? this.width : 0;
                
                if (weaponStats.pattern === 'single' || weaponStats.pattern === 'single_big') {
                    this.bullets.push({
                        worldX: this.worldX + bulletXOffset, worldY: bulletY,
                        radius: weaponStats.bulletRadius, color: weaponStats.bulletColor,
                        speedX: (this.facingRight ? 1 : -1) * weaponStats.bulletSpeed, speedY: 0,
                        damage: weaponStats.damage
                    });
                } else if (weaponStats.pattern === 'triple_spread') {
                    const angles = [-0.2, 0, 0.2];
                    angles.forEach(angle => {
                        this.bullets.push({
                            worldX: this.worldX + bulletXOffset, worldY: bulletY,
                            radius: weaponStats.bulletRadius, color: weaponStats.bulletColor,
                            speedX: Math.cos(angle) * (this.facingRight ? 1 : -1) * weaponStats.bulletSpeed,
                            speedY: Math.sin(angle) * weaponStats.bulletSpeed,
                            damage: weaponStats.damage
                        });
                    });
                }
                if (weaponStats.ammo !== Infinity) {
                    if (currentWeaponKey === 'feather_spread') this.P_feather_spread_ammo--;
                    else if (currentWeaponKey === 'egg_launcher') this.P_egg_launcher_ammo--;
                }
                this.updateWeaponUI();
            },
            
            useSkill: function() {
                if (gameRunning && !gameOver && skillReady) {
                    skillReady = false;
                    lastSkillTime = Date.now();
                    skillStatusDisplay.textContent = "技能: 冷卻中...";
                    playSound('skill_use');

                    let target = null;
                    if (activeBoss) {
                        target = activeBoss;
                    } else {
                        let closestEnemy = null;
                        let minDistance = Infinity;

                        enemies.forEach(enemy => {
                            const screenX = enemy.worldX - cameraX;
                            if (screenX > -enemy.width && screenX < canvas.width) {
                                const dx = (enemy.worldX + enemy.width / 2) - (this.worldX + this.width / 2);
                                const dy = (enemy.worldY + enemy.height / 2) - (this.worldY + this.height / 2);
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestEnemy = enemy;
                                }
                            }
                        });
                        target = closestEnemy;
                    }

                    const bulletOriginX = this.worldX + this.width / 2;
                    const bulletOriginY = this.worldY + this.height / 2;

                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            let speedX, speedY;
                            const bulletSpeed = 10;

                            if (target) {
                                const targetCenterX = target.worldX + target.width / 2;
                                const targetCenterY = target.worldY + target.height / 2;
                                const angle = Math.atan2(targetCenterY - bulletOriginY, targetCenterX - bulletOriginX);
                                speedX = Math.cos(angle) * bulletSpeed;
                                speedY = Math.sin(angle) * bulletSpeed;
                            } else {
                                speedX = (this.facingRight ? 1 : -1) * bulletSpeed;
                                speedY = 0;
                            }

                            this.bullets.push({
                                worldX: bulletOriginX,
                                worldY: bulletOriginY,
                                radius: 8,
                                speedX: speedX,
                                speedY: speedY,
                                color: '#FF4500',
                                isSkillBullet: true,
                                damage: 30
                            });
                        }, i * 120);
                    }

                    setTimeout(() => {
                        skillReady = true;
                        skillStatusDisplay.textContent = "技能: 就緒! (S)";
                    }, SKILL_COOLDOWN);
                }
            },

            switchWeapon: function() { 
                this.currentWeaponIndex = (this.currentWeaponIndex + 1) % this.weapons.length;
                this.updateWeaponUI();
            },
            updateWeaponUI: function() {
                const currentWeaponKey = this.weapons[this.currentWeaponIndex];
                const weaponStats = WEAPON_TYPES[currentWeaponKey];
                let ammoText = "";
                if (weaponStats.ammo !== Infinity) {
                    let currentAmmoForDisplay = 0;
                    if (currentWeaponKey === 'feather_spread') currentAmmoForDisplay = this.P_feather_spread_ammo;
                    else if (currentWeaponKey === 'egg_launcher') currentAmmoForDisplay = this.P_egg_launcher_ammo;
                    ammoText = ` (${currentAmmoForDisplay}/${weaponStats.maxAmmo})`;
                }
                 weaponDisplay.textContent = `武器: ${weaponStats.name}${ammoText}`;
            },
            addWeapon: function(weaponKey) {
                if (!this.weapons.includes(weaponKey)) {
                    this.weapons.push(weaponKey);
                    if (WEAPON_TYPES[weaponKey].ammo !== Infinity) {
                        if(weaponKey === 'feather_spread') this.P_feather_spread_ammo = WEAPON_TYPES[weaponKey].maxAmmo;
                        else if(weaponKey === 'egg_launcher') this.P_egg_launcher_ammo = WEAPON_TYPES[weaponKey].maxAmmo;
                    }
                    messageDisplay.textContent = `獲得新武器: ${WEAPON_TYPES[weaponKey].name}!`;
                    playSound('pickup_weapon');
                } else {
                     if (WEAPON_TYPES[weaponKey].ammo !== Infinity) {
                        if(weaponKey === 'feather_spread') this.P_feather_spread_ammo = WEAPON_TYPES[weaponKey].maxAmmo;
                        else if(weaponKey === 'egg_launcher') this.P_egg_launcher_ammo = WEAPON_TYPES[weaponKey].maxAmmo;
                        messageDisplay.textContent = `${WEAPON_TYPES[weaponKey].name} 彈藥已補充!`;
                        playSound('pickup_health');
                     }
                }
                setTimeout(()=> messageDisplay.textContent = "", 2000);
                this.updateWeaponUI();
            },

            jump: function() {
                if (this.jumps > 0 && gameRunning && !gameOver) {
                    this.dy = JUMP_FORCE;
                    this.grounded = false;
                    const isDouble = this.jumps < this.maxJumps;
                    this.jumps--;
                    playSound('player_jump', { isDoubleJump: isDouble });
                }
            },

            draw: function() { 
                const screenX = this.worldX - cameraX;
                if (this.invincible && Math.floor(Date.now() / 100) % 2 === 0) {
                } else {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(screenX + 5, this.worldY + 5, this.width - 10, this.height - 10);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(screenX + this.width / 2 - 6, this.worldY - 2, 12, 6);
                    ctx.fillStyle = 'white';
                    const eyeX = this.facingRight ? screenX + this.width * 0.65 : screenX + this.width * 0.15;
                    ctx.fillRect(eyeX, this.worldY + this.height * 0.25, 8, 8);
                    ctx.fillStyle = 'black';
                    ctx.fillRect(eyeX + 2, this.worldY + this.height * 0.25 + 2, 4, 4);
                    ctx.fillStyle = '#FFA500';
                    const beakTipX = this.facingRight ? screenX + this.width + 8 : screenX - 8;
                    const beakBaseX = this.facingRight ? screenX + this.width - 5 : screenX + 5;
                    ctx.beginPath(); ctx.moveTo(beakBaseX, this.worldY + this.height * 0.45);
                    ctx.lineTo(beakTipX, this.worldY + this.height * 0.55);
                    ctx.lineTo(beakBaseX, this.worldY + this.height * 0.65); ctx.closePath(); ctx.fill();
                    
                    const currentWeaponKey = this.weapons[this.currentWeaponIndex];
                    const weaponY = this.worldY + this.height * 0.5;
                    ctx.fillStyle = '#666';
                    if (this.facingRight) {
                        const weaponX = screenX + this.width - 10;
                        switch(currentWeaponKey) {
                            case 'peck_cannon':
                                ctx.fillRect(weaponX, weaponY, 20, 8);
                                break;
                            case 'feather_spread':
                                ctx.fillRect(weaponX, weaponY - 4, 25, 16);
                                ctx.fillRect(weaponX + 25, weaponY - 2, 5, 12);
                                break;
                            case 'egg_launcher':
                                ctx.fillStyle = '#4a4a4a';
                                ctx.fillRect(weaponX - 5, weaponY - 8, 30, 16);
                                ctx.beginPath();
                                ctx.arc(weaponX + 25, weaponY, 10, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                        }
                    } else {
                        const weaponX = screenX - 10;
                         switch(currentWeaponKey) {
                            case 'peck_cannon':
                                ctx.fillRect(weaponX, weaponY, 20, 8);
                                break;
                            case 'feather_spread':
                                ctx.fillRect(weaponX - 15, weaponY - 4, 25, 16);
                                ctx.fillRect(weaponX - 20, weaponY - 2, 5, 12);
                                break;
                            case 'egg_launcher':
                                ctx.fillStyle = '#4a4a4a';
                                ctx.fillRect(weaponX - 15, weaponY - 8, 30, 16);
                                ctx.beginPath();
                                ctx.arc(weaponX - 15, weaponY, 10, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                        }
                    }

                    ctx.fillStyle = '#DAA520';
                    ctx.fillRect(screenX + this.width * 0.2, this.worldY + this.height * 0.4, this.width * 0.6, 8);
                    ctx.fillStyle = '#FFA500';
                    const legY = this.worldY + this.height - 5;
                    ctx.fillRect(screenX + this.width * 0.3 - 2, legY, 4, 10);
                    ctx.fillRect(screenX + this.width * 0.7 - 2, legY, 4, 10);
                }

                this.bullets.forEach(bullet => {
                    ctx.beginPath();
                    ctx.arc(bullet.worldX - cameraX, bullet.worldY, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = bullet.color;
                    ctx.fill();
                    ctx.closePath();
                });
            },
            update: function() {
                if (this.invincibleTimer > 0) {
                    this.invincibleTimer -= 1000/60; 
                    if (this.invincibleTimer <= 0) {
                        this.invincible = false;
                    }
                }

                this.worldX += this.dx;
                if (this.dx > 0) this.facingRight = true; if (this.dx < 0) this.facingRight = false;
                
                this.dy += GRAVITY;
                this.worldY += this.dy;
                
                this.grounded = false;

                platforms.forEach(p => {
                    if (this.worldX + this.width > p.worldX && this.worldX < p.worldX + p.width &&
                        this.worldY + this.height >= p.worldY && this.worldY + this.height - this.dy <= p.worldY + 1) {
                        this.worldY = p.worldY - this.height;
                        this.dy = 0;
                        this.grounded = true;
                        this.jumps = this.maxJumps;
                    }
                });

                if (this.worldY + this.height > canvas.height + PLAYER_HEIGHT * 2) { playerHealth = 0; gameOver = true; } 
                if (this.worldX < cameraX && !bossActive) this.worldX = cameraX;
                if (this.worldX < 0) this.worldX = 0;

                this.bullets.forEach((bullet, index) => {
                    bullet.worldX += bullet.speedX; bullet.worldY += bullet.speedY;
                    if (bullet.worldX < cameraX - 50 || bullet.worldX > cameraX + canvas.width + 50 || bullet.worldY < -50 || bullet.worldY > canvas.height + 50) {
                        this.bullets.splice(index, 1);
                    }
                });
            }
        };

        // --- 敵人建構函式與原型方法 (★ FIXED) ---
        function Enemy(worldX, worldY, width, height, color, health, type, shootInterval = 2000, movePattern = 'static', damage = 6, specialCooldown = 10000) {
            this.worldX = worldX; this.worldY = worldY; this.width = width; this.height = height;
            this.color = color; this.health = health; this.maxHealth = health; this.type = type;
            this.bullets = []; this.lastShotTime = 0; this.shootInterval = shootInterval;
            this.speedX = (movePattern === 'patrol' || movePattern === 'chase' ? (Math.random() > 0.5 ? 1 : -1) * (type === 'eggplant' ? 2.5 : 1.2) : 0);
            this.originalX = worldX; this.patrolRange = 50 + Math.random()*50;
            this.movePattern = movePattern;
            
            // ★ FIX: 確保傷害值被正確設定
            this.damage = damage;
            this.contactDamage = damage;

            this.isBoss = type.startsWith('boss_');
            this.isRaged = false;
            this.specialAttackCooldown = specialCooldown;
            this.lastSpecialAttack = Date.now();
            this.attackPhase = 0;
            this.attackTimer = 0;
            this.targetX = 0;
            this.targetY = 0;
        }

        Enemy.prototype.draw = function() {
            const screenX = this.worldX - cameraX;
            if (screenX + this.width < 0 || screenX > canvas.width) return;
            
            ctx.save();
            switch(this.type) {
                case 'tomato':
                    ctx.fillStyle = '#FF6347';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.worldY + this.height / 2, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#32CD32';
                    ctx.fillRect(screenX + this.width / 2 - 2, this.worldY, 4, 6);
                    break;
                case 'cabbage':
                    ctx.fillStyle = '#98FB98';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.worldY + this.height / 2, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#3CB371';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.worldY + this.height / 2, this.width / 3, Math.PI * 0.5, Math.PI * 1.8);
                    ctx.stroke();
                    break;
                case 'carrot':
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.moveTo(screenX, this.worldY + this.height);
                    ctx.lineTo(screenX + this.width, this.worldY + this.height);
                    ctx.lineTo(screenX + this.width / 2, this.worldY);
                    ctx.fill();
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(screenX + this.width/2 - 5, this.worldY - 5, 10, 5);
                    break;
                case 'eggplant':
                    ctx.fillStyle = '#4B0082';
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width / 2, this.worldY + this.height / 2, this.width / 2, this.height/2.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#9400D3';
                    ctx.fillRect(screenX + this.width * 0.2, this.worldY + this.height * 0.4, this.width * 0.6, 10);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(screenX + this.width * 0.3, this.worldY + this.height * 0.2, 5, 5);
                    ctx.fillRect(screenX + this.width * 0.7 - 5, this.worldY + this.height * 0.2, 5, 5);
                    break;
                case 'boss_cabbage_king':
                    ctx.fillStyle = this.isRaged ? '#ff6b6b' : this.color;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.worldY + this.height / 2, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width * 0.2, this.worldY + 10);
                    ctx.lineTo(screenX + this.width * 0.8, this.worldY + 10);
                    ctx.lineTo(screenX + this.width * 0.8, this.worldY - 10);
                    ctx.lineTo(screenX + this.width * 0.5, this.worldY);
                    ctx.lineTo(screenX + this.width * 0.2, this.worldY - 10);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'boss_tomato_lord':
                    ctx.fillStyle = this.isRaged ? '#ff4757' : this.color;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, this.worldY + this.height / 2, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.fillRect(screenX + this.width * 0.2, this.worldY + this.height*0.3, 15, 15);
                    ctx.fillRect(screenX + this.width * 0.8 - 15, this.worldY + this.height*0.3, 15, 15);
                    ctx.fillStyle = 'black';
                    ctx.fillRect(screenX + this.width * 0.2 + 5, this.worldY + this.height*0.3 + 5, 5, 5);
                    ctx.fillRect(screenX + this.width * 0.8 - 10, this.worldY + this.height*0.3 + 5, 5, 5);
                    break;
                default:
                    ctx.fillStyle = this.isRaged ? '#ff6b6b' : this.color;
                    ctx.fillRect(screenX, this.worldY, this.width, this.height);
                    break;
            }
            ctx.restore();

            if (this.isBoss) {
                ctx.fillStyle = 'red'; ctx.fillRect(screenX, this.worldY - 15, this.width, 8);
                ctx.fillStyle = 'green'; ctx.fillRect(screenX, this.worldY - 15, (this.health / this.maxHealth) * this.width, 8);
            }
            
            this.bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.worldX - cameraX, bullet.worldY, bullet.radius, 0, Math.PI * 2);
                ctx.fillStyle = bullet.color; ctx.fill(); ctx.closePath();
            });
        };

        // ★★★ MODIFIED: 敵人更新，加入全新魔王攻擊邏輯 ★★★
        Enemy.prototype.update = function() {
            const screenX = this.worldX - cameraX;
            if (!this.isBoss && (screenX + this.width < -200 || screenX > canvas.width + 200) ) return;
            
            const now = Date.now();

            if(this.isBoss){
                 // 狂暴模式檢查
                 if(this.health / this.maxHealth < 0.5 && !this.isRaged) {
                     this.isRaged = true;
                     this.shootInterval *= 0.7; // 攻擊速度變快
                     this.specialAttackCooldown *= 0.8;
                     messageDisplay.textContent = `${activeBoss.bossName} 狂暴了！`;
                     setTimeout(() => messageDisplay.textContent = "", 2000);
                 }
                // 檢查是否該發動特殊攻擊
                if (this.attackPhase === 0 && now - this.lastSpecialAttack > this.specialAttackCooldown) {
                    this.attackPhase = 1;
                    this.attackTimer = 0;
                    this.lastSpecialAttack = now;
                }

                // ★ NEW: 各魔王獨特AI
                switch(this.type){
                    case 'boss_cabbage_king':
                        // 特殊攻擊：滾動突襲
                        if(this.attackPhase === 1){
                           this.worldY = canvas.height - 60 - this.height; // 移動到地面
                           this.speedX = player.worldX < this.worldX ? -7 : 7; // 朝玩家方向
                           this.attackPhase = 2;
                        } else if (this.attackPhase === 2){
                            this.worldX += this.speedX;
                            if(this.worldX < activeBoss.initialArenaX || this.worldX + this.width > activeBoss.initialArenaX + canvas.width){
                                this.speedX = 0;
                                this.attackPhase = 0; // 結束
                            }
                        } else {
                            // 普通攻擊：散射
                            if (now - this.lastShotTime > this.shootInterval) {
                                this.lastShotTime = now;
                                for(let i = -1; i <= 1; i++) {
                                     this.bullets.push({
                                        worldX: this.worldX + this.width / 2, worldY: this.worldY + this.height / 2, radius: 8,
                                        speedX: Math.cos(i*0.3) * 4 * (player.worldX < this.worldX ? -1 : 1), speedY: Math.sin(i*0.3) * 4,
                                        color: '#abffb1', damage: this.damage, creationX: this.worldX, maxRange: ENEMY_BULLET_MAX_RANGE
                                    });
                                }
                            }
                        }
                        break;

                    case 'boss_tomato_lord':
                        // 特殊攻擊：番茄醬噴發
                        if(this.attackPhase === 1){
                            this.targetY = this.worldY - 100; // 向上跳
                            this.attackPhase = 2;
                        } else if (this.attackPhase === 2) {
                            this.worldY -= 5;
                            if(this.worldY <= this.targetY) this.attackPhase = 3;
                        } else if (this.attackPhase === 3) { // 在空中噴發
                            for(let i=0; i<12; i++){
                                const angle = (i/12) * Math.PI * 2;
                                environmentalHazards.push({
                                    type: 'puddle', x: this.worldX + this.width/2, y: canvas.height - 70, radius: 20, duration: 300, damage: 5
                                });
                            }
                            this.attackPhase = 4;
                        } else if (this.attackPhase === 4) {
                            this.worldY += 8; // 落下
                            if(this.worldY >= canvas.height - 60 - this.height) this.attackPhase = 0;
                        } else {
                            // 普通攻擊：追蹤彈
                            if (now - this.lastShotTime > this.shootInterval) {
                                this.lastShotTime = now;
                                this.bullets.push({
                                    worldX: this.worldX + this.width / 2, worldY: this.worldY + this.height / 2, radius: 10,
                                    speedX: 0, speedY: 0, color: '#ff6347', damage: this.damage, creationX: this.worldX, maxRange: ENEMY_BULLET_MAX_RANGE,
                                    homing: true, lifetime: 120 // 追蹤2秒
                                });
                            }
                        }
                        break;
                    
                    // 其他魔王邏輯...
                }

            } else { // 小兵邏輯
                if (this.movePattern === 'chase' && Math.abs(player.worldX - this.worldX) < 300) {
                    if (player.worldX < this.worldX) this.speedX = -1.5;
                    else this.speedX = 1.5;
                    this.worldX += this.speedX;
                } else if (this.movePattern === 'patrol') {
                    this.worldX += this.speedX;
                    if (this.worldX > this.originalX + this.patrolRange || this.worldX < this.originalX - this.patrolRange) { this.speedX *= -1; }
                }

                 if (now - this.lastShotTime > this.shootInterval && Math.abs(player.worldX - this.worldX) < 400) {
                     this.lastShotTime = now;
                     const angle = Math.atan2((player.worldY + player.height/2) - (this.worldY + this.height/2), (player.worldX + player.width/2) - (this.worldX + this.width/2));
                     this.bullets.push({
                        worldX: this.worldX + this.width/2, worldY: this.worldY + this.height/2, radius: 5,
                        speedX: Math.cos(angle) * 4, speedY: Math.sin(angle) * 4,
                        color: this.type === 'eggplant' ? '#9400D3' : '#FF6347', damage: this.damage,
                        creationX: this.worldX, maxRange: ENEMY_BULLET_MAX_RANGE
                    });
                 }
            }

            // 子彈更新
            this.bullets.forEach((bullet, index) => {
                if(bullet.homing && bullet.lifetime > 0){
                    const angle = Math.atan2((player.worldY + player.height/2) - bullet.worldY, (player.worldX + player.width/2) - bullet.worldX);
                    bullet.speedX += Math.cos(angle) * 0.2;
                    bullet.speedY += Math.sin(angle) * 0.2;
                    // 限制最大速度
                    const speed = Math.sqrt(bullet.speedX**2 + bullet.speedY**2);
                    if(speed > 3){
                       bullet.speedX = (bullet.speedX / speed) * 3;
                       bullet.speedY = (bullet.speedY / speed) * 3;
                    }
                    bullet.lifetime--;
                }
                bullet.worldX += bullet.speedX; bullet.worldY += bullet.speedY;
                if (bullet.worldX < cameraX - 50 || bullet.worldX > cameraX + canvas.width + 50) {
                    this.bullets.splice(index, 1);
                }
            });
        };


        let enemies = []; let collectibles = []; let platforms = [];
        const MIN_PLATFORM_Y = canvas.height - 50; const MAX_PLATFORM_Y = 150;
        const PLATFORM_MIN_WIDTH = 100;
        const PLATFORM_MAX_WIDTH = 280;
        const PLATFORM_MIN_GAP_X = 60;
        const PLATFORM_MAX_GAP_X = 160;
        const PLATFORM_MIN_GAP_Y = 20; const PLATFORM_MAX_GAP_Y = 120;

        const PLATFORM_STYLES = ['grass', 'brick', 'stone', 'wood'];
        function Platform(worldX, worldY, width, height, style) {
            this.worldX = worldX; this.worldY = worldY; this.width = width; this.height = height;
            this.style = style;
            
            this.draw = function() {
                const screenX = this.worldX - cameraX;
                if (screenX + this.width < 0 || screenX > canvas.width) return;
                
                ctx.save();
                switch(this.style) {
                    case 'grass':
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(screenX, this.worldY, this.width, this.height);
                        ctx.fillStyle = '#228B22';
                        ctx.fillRect(screenX, this.worldY, this.width, this.height * 0.3);
                        break;
                    case 'brick':
                        ctx.fillStyle = '#B22222';
                        ctx.fillRect(screenX, this.worldY, this.width, this.height);
                        ctx.strokeStyle = '#2F4F4F';
                        ctx.lineWidth = 2;
                        for (let y = 0; y < this.height; y += 15) {
                            ctx.beginPath(); ctx.moveTo(screenX, this.worldY + y); ctx.lineTo(screenX + this.width, this.worldY + y); ctx.stroke();
                        }
                        for (let x = 0; x < this.width; x += 30) {
                             ctx.beginPath(); ctx.moveTo(screenX + x, this.worldY); ctx.lineTo(screenX + x, this.worldY + this.height); ctx.stroke();
                        }
                        break;
                    case 'stone':
                         ctx.fillStyle = '#696969';
                         ctx.fillRect(screenX, this.worldY, this.width, this.height);
                         ctx.fillStyle = 'rgba(0,0,0,0.1)';
                         for (let i=0; i<20; i++) {
                             ctx.fillRect(screenX + Math.random() * this.width, this.worldY + Math.random() * this.height, 3, 3);
                         }
                        break;
                    case 'wood':
                        ctx.fillStyle = '#D2B48C';
                        ctx.fillRect(screenX, this.worldY, this.width, this.height);
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = 1;
                        for (let i=0; i<5; i++) {
                            ctx.beginPath();
                            ctx.moveTo(screenX, this.worldY + Math.random() * this.height);
                            ctx.bezierCurveTo(screenX + this.width * 0.3, this.worldY + Math.random() * this.height, screenX + this.width * 0.7, this.worldY + Math.random() * this.height, screenX + this.width, this.worldY + Math.random() * this.height);
                            ctx.stroke();
                        }
                        break;
                }
                ctx.restore();
            };
        }

        function Collectible(worldX, worldY, type, value) {
            this.worldX = worldX; this.worldY = worldY; this.type = type; this.value = value;
            this.width = 20; this.height = 20; this.collected = false;
            this.draw = function() {
                if (this.collected) return;
                const screenX = this.worldX - cameraX;
                if (screenX + this.width < 0 || screenX > canvas.width) return;
                ctx.fillStyle = this.type === 'weapon' ? '#00FFFF' : (this.type === 'health' ? '#FF69B4' : '#FFFF00');
                ctx.fillRect(screenX, this.worldY, this.width, this.height);
                if (this.type === 'weapon') {
                    ctx.fillStyle = 'black'; ctx.font = '15px Courier New';
                    ctx.fillText(WEAPON_TYPES[this.value] ? WEAPON_TYPES[this.value].name[0] : 'W' , screenX + 5, this.worldY + 15);
                } else if (this.type === 'health') {
                    ctx.fillStyle = 'white'; ctx.font = '15px Courier New';
                    ctx.fillText('H' , screenX + 5, this.worldY + 15);
                }
            }
        }
        
        function generateSegment(startX) {
            let currentX = startX; const endX = startX + canvas.width * 1.5;
            let lastPlatformY = canvas.height - 80 - Math.random() * 100;
            if (startX === 0) {
                platforms.push(new Platform(0, canvas.height - 60, 300, 60, 'grass'));
                currentX = 300 + PLATFORM_MIN_GAP_X; lastPlatformY = canvas.height - 60;
                collectibles.push(new Collectible(150, canvas.height - 90, 'weapon', 'feather_spread'));
                collectibles.push(new Collectible(200, canvas.height - 90, 'health', 20));
            }

            while (currentX < endX) {
                const gapX = PLATFORM_MIN_GAP_X + Math.random() * (PLATFORM_MAX_GAP_X - PLATFORM_MIN_GAP_X);
                currentX += gapX;
                
                let newPlatformY = lastPlatformY + (Math.random() * 2 - 1) * PLATFORM_MAX_GAP_Y;
                newPlatformY = Math.max(MAX_PLATFORM_Y, Math.min(MIN_PLATFORM_Y, newPlatformY));
                
                const platformWidth = PLATFORM_MIN_WIDTH + Math.random() * (PLATFORM_MAX_WIDTH - PLATFORM_MIN_WIDTH);
                const platformHeight = 20 + Math.random() * 20;
                const platformStyle = PLATFORM_STYLES[Math.floor(Math.random() * PLATFORM_STYLES.length)];
                platforms.push(new Platform(currentX, newPlatformY, platformWidth, platformHeight, platformStyle));

                if (!bossActive && Math.random() < 0.45) {
                    const enemyRand = Math.random();
                    let enemyType, enemyW, enemyH, movePattern, damage;
                    if (enemyRand < 0.3) {
                        enemyType = 'tomato'; enemyW = 25; enemyH = 25; movePattern = 'patrol'; damage = 5;
                    } else if (enemyRand < 0.6) {
                        enemyType = 'cabbage'; enemyW = 28; enemyH = 28; movePattern = 'chase'; damage = 7;
                    } else if (enemyRand < 0.85) {
                        enemyType = 'carrot'; enemyW = 20; enemyH = 30; movePattern = 'patrol'; damage = 5;
                    } else {
                        enemyType = 'eggplant'; enemyW = 22; enemyH = 35; movePattern = 'patrol'; damage = 10;
                    }
                    enemies.push(new Enemy(currentX + platformWidth / 2 - 12, newPlatformY - enemyH, enemyW, enemyH, null, enemyType === 'eggplant' ? 5 : 1, enemyType, 2500 - currentMajorStage * 120, movePattern, damage));
                }
                if (!bossActive && Math.random() < 0.04) {
                    const weaponKeys = ['feather_spread', 'egg_launcher'];
                    const randomWeaponKey = weaponKeys[Math.floor(Math.random() * weaponKeys.length)];
                    collectibles.push(new Collectible(currentX + platformWidth / 2, newPlatformY - 30, 'weapon', randomWeaponKey));
                } else if (!bossActive && Math.random() < 0.03) {
                     collectibles.push(new Collectible(currentX + platformWidth / 2, newPlatformY - 30, 'health', 20));
                }
                lastPlatformY = newPlatformY; currentX += platformWidth;
            }
            worldGeneratedUpToX = Math.max(worldGeneratedUpToX, endX);
        }

        function generateBossArena() {
            platforms = platforms.filter(p => p.worldX + p.width < cameraX || p.worldX > cameraX + canvas.width);
            environmentalHazards = [];
            
            const arenaStartX = cameraX;
            platforms.push(new Platform(arenaStartX - 50, canvas.height - 60, canvas.width + 100, 60, 'stone'));
            platforms.push(new Platform(arenaStartX + 100, canvas.height - 180, 150, 20, 'stone'));
            platforms.push(new Platform(arenaStartX + canvas.width - 250, canvas.height - 180, 150, 20, 'stone'));
            platforms.push(new Platform(arenaStartX + canvas.width/2 - 100, canvas.height - 280, 200, 20, 'stone'));
        }

        function manageLevelGeneration() {
            if (bossActive) return;
            if (cameraX + canvas.width * 1.2 > worldGeneratedUpToX) { generateSegment(worldGeneratedUpToX); }
            platforms = platforms.filter(p => p.worldX + p.width > cameraX - canvas.width);
            enemies = enemies.filter(e => e.worldX + e.width > cameraX - canvas.width || e.isBoss);
            collectibles = collectibles.filter(c => c.worldX + c.width > cameraX - canvas.width);
        }

        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (!gameRunning && (e.code === 'Enter' || e.code === 'Space')) { startButton.click(); return; }
            if (!gameRunning || gameOver) return;
            
            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                e.preventDefault();
                player.jump(); 
            }
            if (e.code === 'Space') player.shoot(); 
            if (e.code === 'KeyS') player.useSkill();
            if (e.code === 'KeyQ' || e.code === 'KeyE') player.switchWeapon();
        });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });
        function handleInput() {
            if (!gameRunning || gameOver) return; player.dx = 0;
            if (keys['ArrowLeft'] || keys['KeyA']) player.dx = -PLAYER_SPEED;
            if (keys['ArrowRight'] || keys['KeyD']) player.dx = PLAYER_SPEED;
        }

        function updateCamera() {
            const targetCamX = player.worldX - canvas.width / 3;
            if (!bossActive) { 
                cameraX += (targetCamX - cameraX) * 0.1; 
            } else if (activeBoss) {
                const arenaCenterX = activeBoss.initialArenaX + canvas.width / 2;
                const desiredCameraX = arenaCenterX - canvas.width / 2;
                cameraX += (desiredCameraX - cameraX) * 0.05;
            }
            if (cameraX < 0) cameraX = 0;
        }

        function checkCollisions() {
            // 玩家子彈 vs 敵人
            player.bullets.forEach((bullet, bulletIndex) => {
                let allTargets = enemies.concat(activeBoss ? [activeBoss] : []);
                allTargets.forEach((target) => {
                    if (!target || !player.bullets[bulletIndex]) return;
                    if (bullet.worldX - bullet.radius < target.worldX + target.width &&
                        bullet.worldX + bullet.radius > target.worldX &&
                        bullet.worldY - bullet.radius < target.worldY + target.height &&
                        bullet.worldY + bullet.radius > target.worldY) {
                        player.bullets.splice(bulletIndex, 1); target.health -= bullet.damage;
                        if (target.health <= 0) {
                            score += target.isBoss ? 500 * currentMajorStage : (10 + currentMajorStage * 2);
                            if (target.isBoss) {
                                playSound('boss_die');
                                bossActive = false; activeBoss = null; environmentalHazards = [];
                                messageDisplay.textContent = `第 ${currentMajorStage} 關魔王已被擊敗!`;
                                setTimeout(()=> messageDisplay.textContent = "", 3000); currentMajorStage++;
                                if (currentMajorStage > MAX_STAGES) { gameWon = true; }
                                else {
                                    nextBossSpawnX = player.worldX + BOSS_SPAWN_INTERVAL + Math.random() * 500;
                                    playerHealth = Math.min(100, playerHealth + 40 + currentMajorStage * 5);
                                    if (currentMajorStage == 2 || currentMajorStage == 4) collectibles.push(new Collectible(target.worldX + target.width/2, target.worldY + target.height/2, 'weapon', 'egg_launcher'));
                                    else if (currentMajorStage == 3) collectibles.push(new Collectible(target.worldX + target.width/2, target.worldY + target.height/2, 'weapon', 'feather_spread'));
                                    else collectibles.push(new Collectible(target.worldX + target.width/2, target.worldY + target.height/2, 'health', 50));
                                }
                            } else { playSound('enemy_die'); const enemyIndex = enemies.indexOf(target); if (enemyIndex > -1) enemies.splice(enemyIndex, 1); }
                        } else { if (target.isBoss) playSound('boss_hit'); }
                        return;
                    }
                });
            });
            // 敵人子彈 vs 玩家
            let allEnemyBulletsSources = enemies.concat(activeBoss ? [activeBoss] : []);
            allEnemyBulletsSources.forEach(source => {
                if(!source) return;
                source.bullets.forEach((bullet, bulletIndex) => {
                    if (bullet.worldX - bullet.radius < player.worldX + player.width &&
                        bullet.worldX + bullet.radius > player.worldX &&
                        bullet.worldY - bullet.radius < player.worldY + player.height &&
                        bullet.worldY + bullet.radius > player.worldY) {
                        source.bullets.splice(bulletIndex, 1);
                        if (!player.invincible) {
                            playerHealth -= bullet.damage;
                            playSound('player_hit');
                            damageOverlay.style.opacity = 1;
                            setTimeout(() => damageOverlay.style.opacity = 0, 100);
                            player.invincible = true;
                            player.invincibleTimer = 1000;
                            if (playerHealth <= 0) { playerHealth = 0; gameOver = true; }
                        }
                    }
                });
            });
            // 敵人 vs 玩家直接碰撞
            allEnemyBulletsSources.forEach(source => {
                 if(!source) return;
                 if (player.worldX < source.worldX + source.width &&
                    player.worldX + player.width > source.worldX &&
                    player.worldY < source.worldY + source.height &&
                    player.worldY + player.height > source.worldY) {
                    if (!player.invincible) {
                        playerHealth -= source.contactDamage; // 直接碰撞傷害更高
                        playSound('player_hit', {volume: 0.15});
                        damageOverlay.style.opacity = 1;
                        setTimeout(() => damageOverlay.style.opacity = 0, 100);
                        player.invincible = true;
                        player.invincibleTimer = 800;
                        if (playerHealth <= 0) { playerHealth = 0; gameOver = true; }
                    }
                }
            });
            // 環境傷害 vs 玩家
            environmentalHazards.forEach(hazard => {
                const dx = player.worldX + player.width/2 - hazard.x;
                const dy = player.worldY + player.height/2 - hazard.y;
                if(Math.sqrt(dx*dx + dy*dy) < player.width/2 + hazard.radius){
                     if (!player.invincible) {
                        playerHealth -= hazard.damage;
                        playSound('player_hit', {volume: 0.1});
                        damageOverlay.style.opacity = 1;
                        setTimeout(() => damageOverlay.style.opacity = 0, 100);
                        player.invincible = true;
                        player.invincibleTimer = 500;
                        if (playerHealth <= 0) { playerHealth = 0; gameOver = true; }
                    }
                }
            });

            // 玩家 vs 收集品
            collectibles.forEach((item, index) => {
                if (!item.collected &&
                    player.worldX < item.worldX + item.width &&
                    player.worldX + player.width > item.worldX &&
                    player.worldY < item.worldY + item.height &&
                    player.worldY + player.height > item.worldY) {
                    item.collected = true;
                    if (item.type === 'weapon') { player.addWeapon(item.value); }
                    else if (item.type === 'health') {
                        playerHealth = Math.min(100, playerHealth + item.value); playSound('pickup_health');
                    }
                }
            });
        }

        function update() {
            if (!gameRunning || gameOver) return;
            handleInput(); player.update(); 
            
            if (!bossActive) {
                manageLevelGeneration();
                gameTime++;
                updateClouds();
            } else {
                // 更新環境傷害
                environmentalHazards.forEach((hazard, index) => {
                    hazard.duration--;
                    if(hazard.duration <= 0){
                        environmentalHazards.splice(index, 1);
                    }
                });
            }

            enemies.forEach(enemy => enemy.update()); if (activeBoss) activeBoss.update();
            updateCamera(); checkCollisions();
            
            muzzleFlashes.forEach((flash, index) => {
                flash.alpha -= 0.15;
                if(flash.alpha <= 0) {
                    muzzleFlashes.splice(index, 1);
                }
            });

            scoreDisplay.textContent = `分數: ${score}`; healthDisplay.textContent = `生命: ${Math.ceil(playerHealth)}`;
            stageDisplay.textContent = `大關卡: ${currentMajorStage > MAX_STAGES ? MAX_STAGES : currentMajorStage}/${MAX_STAGES}`;
            progressDisplay.textContent = `進度: ${Math.floor(player.worldX / 10)}m`;

            if (!bossActive && !gameWon && currentMajorStage <= MAX_STAGES && player.worldX >= nextBossSpawnX) {
                bossActive = true; 
                enemies = [];
                
                generateBossArena();
                
                const bossData = BOSS_TYPES[currentMajorStage - 1];
                const bossHealth = bossData.health + currentMajorStage * 100;
                
                const spawnX = cameraX + canvas.width - bossData.width - 100;
                const spawnY = canvas.height - 60 - bossData.height;

                activeBoss = new Enemy(
                    spawnX, spawnY,
                    bossData.width, bossData.height,
                    bossData.color, bossHealth, bossData.type,
                    1800 - currentMajorStage * 150,
                    'static', bossData.damage, bossData.specialCooldown
                );
                activeBoss.initialArenaX = cameraX;
                activeBoss.bossName = bossData.name;

                messageDisplay.textContent = `魔王來襲: ${bossData.name}！`;
                setTimeout(()=> messageDisplay.textContent = "", 3000);
                playSound('boss_die', {volume:0.1, duration: 0.5});
            }

            if (!skillReady) {
                const timeSinceSkill = Date.now() - lastSkillTime; const cooldownRemaining = Math.max(0, SKILL_COOLDOWN - timeSinceSkill);
                skillStatusDisplay.textContent = `技能: 冷卻 ${Math.ceil(cooldownRemaining / 1000)}s`;
                if (cooldownRemaining <= 0) { skillReady = true; skillStatusDisplay.textContent = "技能: 就緒! (S)"; }
            }
            if (gameWon && !gameOver) { gameOver = true; }
        }
        
        function updateClouds() {
            clouds.forEach(cloud => {
                cloud.x -= cloud.speed;
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width;
                }
            });
        }
        
        function draw() {
            drawBackground();

            if (!gameRunning && !gameOver && !gameWon) { 
                displayStartScreen(); 
                return; 
            }

            platforms.forEach(p => p.draw()); 
            collectibles.forEach(c => c.draw());
            
            // ★ NEW: 繪製環境傷害
            environmentalHazards.forEach(hazard => {
                if(hazard.type === 'puddle'){
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.beginPath();
                    ctx.arc(hazard.x - cameraX, hazard.y, hazard.radius, 0, Math.PI*2);
                    ctx.fill();
                }
            });

            player.draw(); 
            enemies.forEach(enemy => enemy.draw()); 
            if (activeBoss) activeBoss.draw();
            
            muzzleFlashes.forEach(flash => {
                ctx.fillStyle = `rgba(255, 223, 0, ${flash.alpha})`;
                ctx.beginPath();
                ctx.arc(flash.x - cameraX, flash.y, 8, 0, Math.PI * 2);
                ctx.fill();
            });

            if (gameOver) { 
                displayGameOverScreen(); 
            }
        }
        
        function drawBackground() {
            const cycleDuration = 3600;
            const timeOfDay = (gameTime * TIME_SCALE) % cycleDuration;
            
            let skyColor1, skyColor2;
            const dawnTime = cycleDuration * 0.25;
            const dayTime = cycleDuration * 0.4;
            const duskTime = cycleDuration * 0.75;
            const nightTime = cycleDuration * 0.9;

            if (timeOfDay < dawnTime) {
                const progress = timeOfDay / dawnTime;
                skyColor1 = lerpColor("#000033", "#3a6ea5", progress);
                skyColor2 = lerpColor("#1a2533", "#87CEEB", progress);
            } else if (timeOfDay < dayTime) {
                skyColor1 = "#3a6ea5";
                skyColor2 = "#87CEEB";
            } else if (timeOfDay < duskTime) {
                const progress = (timeOfDay - dayTime) / (duskTime - dayTime);
                skyColor1 = lerpColor("#3a6ea5", "#ff8c00", progress);
                skyColor2 = lerpColor("#87CEEB", "#ffc04d", progress);
            } else {
                const progress = (timeOfDay - duskTime) / (cycleDuration - duskTime);
                skyColor1 = lerpColor("#ff8c00", "#000033", progress);
                skyColor2 = lerpColor("#ffc04d", "#1a2533", progress);
            }

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, skyColor1);
            gradient.addColorStop(1, skyColor2);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            const celestialAngle = (timeOfDay / cycleDuration) * 2 * Math.PI - Math.PI / 2;
            const celestialX = canvas.width / 2 + Math.cos(celestialAngle) * canvas.width * 0.4;
            const celestialY = canvas.height * 0.8 + Math.sin(celestialAngle) * canvas.height * 0.7;

            if (timeOfDay > dawnTime * 0.5 && timeOfDay < duskTime * 1.1) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 40, 0, 2 * Math.PI);
                ctx.fill();
            } else {
                ctx.fillStyle = 'rgba(240, 240, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 30, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.restore();

            if (timeOfDay > duskTime * 0.95 || timeOfDay < dawnTime * 1.05) {
                stars.forEach(star => {
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.fillRect(star.x, star.y, star.size, star.size);
                    star.opacity += star.flickerSpeed;
                    if (star.opacity > 1 || star.opacity < 0.2) {
                        star.flickerSpeed *= -1;
                    }
                });
            }

            clouds.forEach(cloud => {
                ctx.fillStyle = cloud.color;
                ctx.globalAlpha = cloud.alpha;
                ctx.fillRect(cloud.x - cameraX * cloud.parallax, cloud.y, cloud.width, cloud.height);
                ctx.globalAlpha = 1.0;
            });
        }

        function lerpColor(a, b, amount) {
            const ah = parseInt(a.replace(/#/g, ''), 16),
                  ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff,
                  bh = parseInt(b.replace(/#/g, ''), 16),
                  br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff,
                  rr = ar + amount * (br - ar),
                  rg = ag + amount * (bg - ag),
                  rb = ab + amount * (bb - ab);

            return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);
        }

        function displayStartScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; ctx.font = '30px "Courier New"'; ctx.textAlign = 'center';
            ctx.fillText('戰鬥雞：無盡征途', canvas.width / 2, canvas.height / 2 - 60);
            ctx.font = '20px "Courier New"';
            ctx.fillText('準備好迎接真正的挑戰了嗎?', canvas.width / 2, canvas.height / 2 -10);
            ctx.fillText('擊敗五大蔬菜魔王，成為雞界傳奇!', canvas.width / 2, canvas.height / 2 + 20);
            ctx.fillText('按"開始遊戲"或 Enter/Space', canvas.width / 2, canvas.height / 2 + 60);
            startButton.style.display = 'block';
        }
        function displayGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = gameWon ? '#2ecc71' : '#e74c3c'; ctx.font = '40px "Courier New"'; ctx.textAlign = 'center';
            if (gameWon) { ctx.fillText('恭喜通關！你是雞界戰神！', canvas.width / 2, canvas.height / 2 - 20); messageDisplay.textContent = `總分數: ${score}，太強了！`; }
            else { ctx.fillText('遊戲結束!', canvas.width / 2, canvas.height / 2 - 20); messageDisplay.textContent = `你變成了第 ${score +1} 份雞排...`; }
            ctx.font = '20px "Courier New"'; ctx.fillStyle = 'white';
            ctx.fillText(`最終分數: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
            ctx.fillText(`最高關卡: ${currentMajorStage > MAX_STAGES ? MAX_STAGES : currentMajorStage}`, canvas.width / 2, canvas.height / 2 + 50);
            ctx.fillText('點擊"重新開始"重新挑戰', canvas.width / 2, canvas.height / 2 + 90);
            startButton.style.display = 'block'; startButton.textContent = "重新開始"; gameRunning = false;
        }

        function initGame() {
            score = 0; currentMajorStage = 1; playerHealth = 100; gameOver = false; gameWon = false;
            bossActive = false; activeBoss = null; cameraX = 0; worldGeneratedUpToX = 0;
            player.worldX = 100; player.worldY = canvas.height - PLAYER_HEIGHT - 100;
            player.dx = 0; player.dy = 0; player.grounded = false; player.bullets = []; player.facingRight = true;
            player.invincible = false; player.invincibleTimer = 0;
            player.jumps = player.maxJumps;

            player.weapons = ['peck_cannon'];
            player.currentWeaponIndex = 0;
            player.P_feather_spread_ammo = WEAPON_TYPES.feather_spread.maxAmmo;
            player.P_egg_launcher_ammo = WEAPON_TYPES.egg_launcher.maxAmmo;

            player.updateWeaponUI();
            skillReady = true; lastSkillTime = 0; skillStatusDisplay.textContent = "技能: 就緒! (S)";
            platforms = []; enemies = []; collectibles = []; muzzleFlashes = []; environmentalHazards = [];
            generateSegment(0); nextBossSpawnX = BOSS_SPAWN_INTERVAL; messageDisplay.textContent = "";

            gameTime = 0;
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.8,
                    size: Math.random() * 2 + 1,
                    opacity: Math.random() * 0.5 + 0.2,
                    flickerSpeed: (Math.random() - 0.5) * 0.02
                });
            }
            clouds = [];
            for (let i = 0; i < 20; i++) {
                const parallax = Math.random() * 0.3 + 0.1;
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.6,
                    width: Math.random() * 100 + 80,
                    height: Math.random() * 20 + 20,
                    speed: parallax * 0.5,
                    parallax: parallax,
                    color: 'rgba(255, 255, 255, 0.7)',
                    alpha: parallax + 0.3
                });
            }
            clouds.sort((a,b) => a.parallax - b.parallax);
        }

        let animationFrameId = null;
        function gameLoop() {
            if (!gameRunning && (gameOver || !gameWon)) {
                 draw();
                 return;
            }
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        startButton.addEventListener('click', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            if (!gameRunning || gameOver) {
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume().catch(e => console.error("AudioContext resume failed:", e));
                }
                initGame();
                gameRunning = true; gameOver = false; gameWon = false;
                startButton.style.display = 'none'; startButton.textContent = "開始遊戲";
                gameLoop();
            }
        });
        
        initGame();
        draw();
    </script>
</body>
</html>
